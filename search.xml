<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>彻底搞懂 JS 中正则表达式</title>
    <url>/posts/308772757/</url>
    <content><![CDATA[<h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part.1"></a>Part.1</h2><p>正则表达式能在字符串中查找匹配特定模式的子字符串。</p><p>在JavaScript中，可以通过斜线 // 来创建，也可以通过<code>new RegExp()</code>来创建，然后就能使用<code>match</code>、<code>test</code>、<code>replace</code>等方法。</p><a id="more"></a><p>你可以事先定义正则表达式，也可以在调用方法时随时定义。</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-3-23-20191011190323.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-3-23-20191011190323.png"><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part.2"></a>Part.2</h2><p>每次匹配一个字符，将多个字符放到方括号 [] 中可以匹配多个匹配的字符。</p><p>用横线 - 匹配字符范围。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-6-8-20191011190607.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-6-8-20191011190607.png"></p><h2 id="Part-3"><a href="#Part-3" class="headerlink" title="Part.3"></a>Part.3</h2><p>在正则表达式末尾添加额外的标记来修改匹配器的行为。</p><p>JavaScript 支持如下标记：</p><ul><li>i = 不区分大小写</li><li>m = 多行匹配</li><li>g = 全局匹配（查找所有匹配，而不是仅查找一个）</li></ul><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-6-24-20191011190623.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-6-24-20191011190623.png"></p><h2 id="Part-4"><a href="#Part-4" class="headerlink" title="Part.4"></a>Part.4</h2><p>在模式开头使用箭头 <code>^</code> 表示“字符串开头”。</p><p>在模式末尾使用美元符号 <code>$</code> 表示“字符串结尾”。</p><p>将多个模式放在一起以匹配更长的字符串。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-6-36-20191011190635.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-6-36-20191011190635.png"></p><h2 id="Part-5"><a href="#Part-5" class="headerlink" title="Part.5"></a>Part.5</h2><p>使用通配符和特殊的转义字符来匹配字符类。</p><p>. = 除了换行之外的任何字符。</p><ul><li>\d = 数字</li><li>\D = 非数字</li><li>\s = 空白</li><li>\S = 非空白</li><li>\n = 新行</li></ul><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-6-49-20191011190648.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-6-49-20191011190648.png"></p><h2 id="Part-6"><a href="#Part-6" class="headerlink" title="Part.6"></a>Part.6</h2><p>用数量修饰符来匹配特定数量的字符。</p><ul><li>*= 零个或多个</li><li>+= 一个或多个</li><li>？= 零个或一个</li><li>{3} = 正好3个</li><li>{2,4} = 2, 3, 或4个</li><li>{2,} = 2或多个</li></ul><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-6-59-20191011190658.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-6-59-20191011190658.png"></p><h2 id="Part-7"><a href="#Part-7" class="headerlink" title="Part.7"></a>Part.7</h2><p>使用括号 () 来分组。</p><p><code>match</code>会返回完整的匹配，外加每个分组，除非你使用了g标记。</p><p>在括号 () 内使用管道符号 | 来表示分组的匹配内容。</p><ul><li>| = 或者</li></ul><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-7-9-20191011190709.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-7-9-20191011190709.png"></p><h2 id="Part-8"><a href="#Part-8" class="headerlink" title="Part.8"></a>Part.8</h2><p>要匹配特殊字符，需要用反斜杠 <code>\</code> 将其转义。</p><p>JS正则表达式中的特殊字符包括：<code>^ $ \ . * + ? ( ) [ ] { } |</code></p><p>所以，要想匹配星号，需要使用：</p><ul><li><code>\*</code></li><li>而不能仅使用 <code>*</code></li></ul><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-7-23-20191011190722.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-7-23-20191011190722.png"></p><h2 id="Part-9"><a href="#Part-9" class="headerlink" title="Part.9"></a>Part.9</h2><p>要想匹配除了特定字符之外的任意字符，可以在方括号内使用^。</p><p>这意味着 ^ 有两种含义，可能会造成混淆。</p><p>当它出现在正则表达式开头时，它表示“字符串开头”；出现在方括号内时，表示“不是这些字符串”。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-7-33-20191011190733.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-7-33-20191011190733.png"></p><h2 id="Part-10"><a href="#Part-10" class="headerlink" title="Part.10"></a>Part.10</h2><p>正则表示可以用来查找并匹配各种东西，比如URL和文件名。</p><p>但是！对于非常复杂的任务，使用正则表达式时一定要小心，比如分析电子邮件（你很容易就会弄得一团糟），或者分析HTML（HTML不是正规的语言，所以没办法完全使用正则表达式来解析）。</p><p>当然，正则表达式还有更多内容，如懒惰 vs 贪婪，前向，捕获等。</p><p>但是，对于绝大多数Web开发者来说，掌握这些最基本的组成部分就够了。</p><hr><blockquote><p>原文：<a href="https://dev.to/chrisachard/intro-to-regex-for-web-developers-2fj4" target="_blank" rel="noopener">https://dev.to/chrisachard/intro-to-regex-for-web-developers-2fj4</a><br>作者：Chris Achard，程序员，日常使用JS, React, Rails和Node，在egghead.io上讲课。<br>本文为 CSDN 翻译，转载请注明来源出处。</p></blockquote><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(11):测试 API</title>
    <url>/posts/442130010/</url>
    <content><![CDATA[<p>Postman 是一款跨平台的发送 HTTP 请求的工具。使用 Postman 可以很容易的测试各种 Web API 接口，也可以编写测试脚本，进行自动化测试。</p><p>Postman 有独立客户端版本，也有 Chrome 插件版。案例中使用的是客户端版，进入<a href="https://www.getpostman.com/" target="_blank" rel="noopener">官方网站</a>下载。</p><a id="more"></a><h2 id="API-集合"><a href="#API-集合" class="headerlink" title="API 集合"></a>API 集合</h2><p>用于测试的 API 请求集合。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-11-%E6%B5%8B%E8%AF%95%20API%5D-2019-10-31-12-0-26.png" alt></p><h3 id="导入集合"><a href="#导入集合" class="headerlink" title="导入集合"></a>导入集合</h3><p>大家可以在 GitHub 里找到配置文件，然后导入。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-11-%E6%B5%8B%E8%AF%95%20API%5D-2019-10-31-12-1-10.png" alt></p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-11-%E6%B5%8B%E8%AF%95%20API%5D-2019-10-31-12-1-22.png" alt></p><p>或者使用以下连接进行导入：</p><figure class="highlight http"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">https://www.getpostman.com/collections/4db8651c29b04f79ce62</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-11-%E6%B5%8B%E8%AF%95%20API%5D-2019-10-31-12-1-35.png" alt></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>API 集合中，使用了 Postman 环境变量，以方便我们修改 API 根地址，和一些测试参数。</p><ol><li><p>打开环境配置界面</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-11-%E6%B5%8B%E8%AF%95%20API%5D-2019-10-31-12-3-58.png" alt></p></li><li><p>点击 Add 添加新环境</p></li><li><p>除了「url」和 「barcode」必须要设置，其它的变量可以为空，或者不设置，测试脚本中会自动设置「token」和 「id」</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-11-%E6%B5%8B%E8%AF%95%20API%5D-2019-10-31-12-6-49.png" alt></p></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试方式有两种：</p><div class="note success"><p>一种是在左侧选择一个请求项，右侧单击「Send」按钮发送请求，一般用在开发中，单独调试某个接口；</p><p>另一种是自动测试，适合对整个接口，进行统一测试。</p></div><p>单个接口测试很简单，这里不在讲解。</p><h3 id="自动测试"><a href="#自动测试" class="headerlink" title="自动测试"></a>自动测试</h3><ol><li><p>选择刚才我们添加的环境 <code>Zilor.Order</code></p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-11-%E6%B5%8B%E8%AF%95%20API%5D-2019-10-31-12-24-2.png" alt></p></li><li><p>打开 API 集合的 Runner 窗口</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-11-%E6%B5%8B%E8%AF%95%20API%5D-2019-10-31-12-12-59.png" alt></p></li><li><p>调整接口测试顺序，务必按照「增」「查」「改」「删」的顺序进行调整</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-11-%E6%B5%8B%E8%AF%95%20API%5D-2019-10-31-12-16-52.png" alt></p></li><li><p>点击蓝色大按钮运行测试，绿色成功，红色失败</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-11-%E6%B5%8B%E8%AF%95%20API%5D-2019-10-31-12-24-53.png" alt></p></li><li><p>如果有失败的请求，可以点击接口名称，查看每一个接口的请求与响应消息。</p></li></ol><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(10):订单明细</title>
    <url>/posts/4240715696/</url>
    <content><![CDATA[<p>需要注意钉钉小程序有个大坑，文档说只支持 GET 和 POST 的请求，但实际所有 Method 都支持。</p><p>不过坑就坑在这里，钉钉小程序只能在 GET 和 POST 的请求中，使用 body 传数据，而 PUT 和 DELETE 请求就只能把数据放在 URL 参数里了。</p><a id="more"></a><h2 id="创建-OrderController-类"><a href="#创建-OrderController-类" class="headerlink" title="创建 OrderController 类"></a>创建 OrderController 类</h2><h3 id="OrderController-cs"><a href="#OrderController-cs" class="headerlink" title="OrderController.cs"></a>OrderController.cs</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"api/order-detail"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderDetailController</span> : <span class="title">ControllerBase</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">private</span> ISelect<orderprimary> _orderSelect { <span class="keyword">get</span>; }</orderprimary></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> BaseRepository<orderdetail> _detailRepo { <span class="keyword">get</span>; }</orderdetail></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrderDetailController</span>(<span class="params">IFreeSql fsql, IHttpContextAccessor httpContextAccessor</span>)</span></span><br><span class="line"><span class="function"></span>  {</span><br><span class="line">    <span class="keyword">var</span> jobnumber = httpContextAccessor.HttpContext.User.Claims.First(c => c.Type == <span class="string">"jobnumber"</span>).Value;</span><br><span class="line">    _orderSelect = fsql.GetRepository<orderprimary>(o => o.State == <span class="number">0</span> && o.CreatedBy == jobnumber).Select;</orderprimary></span><br><span class="line">    _detailRepo = fsql.GetRepository<orderdetail>();</orderdetail></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Action ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="创建接口方法"><a href="#创建接口方法" class="headerlink" title="创建接口方法"></a>创建接口方法</h2><h3 id="添加订单明细"><a href="#添加订单明细" class="headerlink" title="添加订单明细"></a>添加订单明细</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task<iactionresult> <span class="title">Post</span>(<span class="params">OrderDetail detail</span>)</iactionresult></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 订单不存在返回404</span></span><br><span class="line">  <span class="keyword">if</span> (!_orderSelect.WhereDynamic(detail.Id).Any()) <span class="keyword">return</span> NotFound();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 商品不存在返回404</span></span><br><span class="line">  <span class="keyword">if</span> (!_detailRepo.Orm.Select<goods>().WhereDynamic(detail.Barcode).Any())</goods></span><br><span class="line">    <span class="keyword">return</span> NotFound(<span class="keyword">new</span> { msg = <span class="string">"商品不存在"</span> });</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">await</span> _detailRepo.InsertAsync(detail);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">null</span>) <span class="keyword">return</span> BadRequest();</span><br><span class="line">  <span class="keyword">return</span> Ok();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="修改订单明细数量"><a href="#修改订单明细数量" class="headerlink" title="修改订单明细数量"></a>修改订单明细数量</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">HttpPut</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task<iactionresult> <span class="title">Put</span>(<span class="params"><span class="keyword">long</span> id, <span class="keyword">string</span> barcode, <span class="keyword">int</span> count</span>)</iactionresult></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">await</span> _detailRepo.Orm.Update<orderdetail>(<span class="keyword">new</span> {id, barcode}).Set(o => o.Count == count).ExecuteAffrowsAsync();</orderdetail></span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">1</span>) <span class="keyword">return</span> BadRequest();</span><br><span class="line">  <span class="keyword">return</span> Ok();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="删除订单商品明细"><a href="#删除订单商品明细" class="headerlink" title="删除订单商品明细"></a>删除订单商品明细</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">HttpDelete</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task<iactionresult> <span class="title">Delete</span>(<span class="params"><span class="keyword">long</span> id, <span class="keyword">string</span> barcode</span>)</iactionresult></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">await</span> _detailRepo.DeleteAsync(o => o.Id == id && o.Barcode == barcode);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">1</span>) <span class="keyword">return</span> BadRequest();</span><br><span class="line">  <span class="keyword">return</span> Ok();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="创建-GoodsController-类"><a href="#创建-GoodsController-类" class="headerlink" title="创建 GoodsController 类"></a>创建 GoodsController 类</h2><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"api/[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GoodsController</span>: <span class="title">ControllerBase</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">private</span> BaseRepository<goods> _goodsRepo { <span class="keyword">get</span>; }</goods></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GoodsController</span>(<span class="params">IFreeSql fsql</span>) </span></span><br><span class="line"><span class="function"></span>  {</span><br><span class="line">    _goodsRepo = fsql.GetRepository<goods>();</goods></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  [<span class="meta">HttpGet</span>]</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task<iactionresult> <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> barcode</span>)</iactionresult></span></span><br><span class="line"><span class="function"></span>  {</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> _goodsRepo.Where(g => g.Barcode == barcode).FirstAsync();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(result == <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">return</span> NotFound();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(result);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(9):订单控制器</title>
    <url>/posts/1551316269/</url>
    <content><![CDATA[<p>接下来，我们编写控制器部分的代码，这里需要注意的是，只有「未确认」的订单，才可以增删改。</p><p>所有的控制器都需要进行认证授权，给控制器类加上<code>Authorize</code>特性。</p><h2 id="创建-OrderController-类"><a href="#创建-OrderController-类" class="headerlink" title="创建 OrderController 类"></a>创建 OrderController 类</h2><h3 id="OrderController-cs"><a href="#OrderController-cs" class="headerlink" title="OrderController.cs"></a>OrderController.cs</h3><a id="more"></a><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"api/order"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderController</span> : <span class="title">ControllerBase</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">string</span> _jobnumber { <span class="keyword">get</span>; }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> BaseRepository<orderprimary> _orderRepo { <span class="keyword">get</span>; }</orderprimary></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrderController</span>(<span class="params">IFreeSql fsql, IHttpContextAccessor httpContextAccessor</span>)</span></span><br><span class="line"><span class="function"></span>  {</span><br><span class="line">    _jobnumber = httpContextAccessor.HttpContext.User.Claims.First(c => c.Type == <span class="string">"jobnumber"</span>).Value;</span><br><span class="line">    _orderRepo = fsql.GetRepository<orderprimary>(o => o.CreatedBy == _jobnumber);</orderprimary></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Action ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="创建接口方法"><a href="#创建接口方法" class="headerlink" title="创建接口方法"></a>创建接口方法</h2><h3 id="添加订单"><a href="#添加订单" class="headerlink" title="添加订单"></a>添加订单</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task<iactionresult> <span class="title">Post</span>(<span class="params"></span>)</iactionresult></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">var</span> newOrder = <span class="keyword">new</span> OrderPrimary</span><br><span class="line">  {</span><br><span class="line">    State = <span class="number">0</span>,</span><br><span class="line">    Date = DateTime.Now.ToString(<span class="string">"yyyy-MM-dd"</span>),</span><br><span class="line">    CreatedBy = _jobnumber,</span><br><span class="line">    CreatedTime = DateTime.Now</span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">await</span> _orderRepo.InsertAsync(newOrder);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Ok(<span class="keyword">new</span></span><br><span class="line">  {</span><br><span class="line">    result.Id,</span><br><span class="line">    date = result.Date</span><br><span class="line">  });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="订单日期修改"><a href="#订单日期修改" class="headerlink" title="订单日期修改"></a>订单日期修改</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">HttpPut</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task<iactionresult> <span class="title">Put</span>(<span class="params"><span class="keyword">long</span> id, <span class="keyword">string</span> date</span>)</iactionresult></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">var</span> order = <span class="keyword">await</span> _orderRepo.Where(o => o.Id == id && o.State == <span class="number">0</span>).FirstAsync();</span><br><span class="line">  <span class="keyword">if</span> (order == <span class="literal">null</span>) <span class="keyword">return</span> NotFound();</span><br><span class="line">  order.Date =  DateTime.Parse(date).ToString(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">await</span> _orderRepo.UpdateAsync(order);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Ok();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="删除订单"><a href="#删除订单" class="headerlink" title="删除订单"></a>删除订单</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">HttpDelete(<span class="meta-string">"{id}"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task<iactionresult> <span class="title">Delete</span>(<span class="params"><span class="keyword">long</span> id</span>)</iactionresult></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">var</span> order = <span class="keyword">await</span> _orderRepo.Where(o => o.Id == id && o.State == <span class="number">0</span>).FirstAsync();</span><br><span class="line">  <span class="keyword">if</span> (order == <span class="literal">null</span>) <span class="keyword">return</span> NotFound();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事务</span></span><br><span class="line">  <span class="keyword">using</span> (<span class="keyword">var</span> uow = _orderRepo.Orm.CreateUnitOfWork())</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">var</span> orderRepo = uow.GetRepository<orderprimary>();</orderprimary></span><br><span class="line">    <span class="keyword">var</span> detailRepo = uow.GetRepository<orderdetail>();</orderdetail></span><br><span class="line">    orderRepo.Delete(order);</span><br><span class="line">    detailRepo.Delete(o => o.Id == id);</span><br><span class="line"></span><br><span class="line">    uow.Commit();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Ok();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="查询用户历史订单"><a href="#查询用户历史订单" class="headerlink" title="查询用户历史订单"></a>查询用户历史订单</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task<iactionresult> <span class="title">Get</span>(<span class="params"><span class="keyword">int</span> pageIndex = <span class="number">1</span>, <span class="keyword">short</span> state = <span class="number">-1</span></span>)</iactionresult></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">await</span> _orderRepo.Select.Page(pageIndex, <span class="number">20</span>)</span><br><span class="line">              .WhereIf(state != <span class="number">-1</span>, o => o.State == state)</span><br><span class="line">              .OrderByDescending(o => o.CreatedTime)</span><br><span class="line">              .From<orderdetail>((op, od) => op.LeftJoin(op => op.Id == od.Id))</orderdetail></span><br><span class="line">              .GroupBy((op, od) => <span class="keyword">new</span> { op.Id, op.Date, op.State })</span><br><span class="line">              .ToListAsync(g => <span class="keyword">new</span></span><br><span class="line">              {</span><br><span class="line">                g.Key.Id,</span><br><span class="line">                g.Key.Date,</span><br><span class="line">                g.Key.State,</span><br><span class="line">                sumCount = g.Sum(g.Value.Item2.Count)</span><br><span class="line">              });</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只缓存前20条</span></span><br><span class="line">  <span class="keyword">return</span> Ok(result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="查询订单"><a href="#查询订单" class="headerlink" title="查询订单"></a>查询订单</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="meta-string">"{id}"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task<iactionresult> <span class="title">Get</span>(<span class="params"><span class="keyword">long</span> id</span>)</iactionresult></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">var</span> order = <span class="keyword">await</span> _orderRepo.Select.Where(o => o.Id == id).FirstAsync();</span><br><span class="line">  <span class="keyword">if</span> (order == <span class="literal">null</span>) <span class="keyword">return</span> NotFound();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> details = <span class="keyword">await</span> _orderRepo.Orm.Select<orderdetail, goods>()</orderdetail,></span><br><span class="line">                .Where((o, g) => o.Barcode == g.Barcode && o.Id == id)</span><br><span class="line">                .ToListAsync((o, g) => <span class="keyword">new</span></span><br><span class="line">                {</span><br><span class="line">                  o.Barcode,</span><br><span class="line">                  g.Name,</span><br><span class="line">                  g.Sort1,</span><br><span class="line">                  g.Sort2,</span><br><span class="line">                  g.Spec,</span><br><span class="line">                  o.Count</span><br><span class="line">                });</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Ok(<span class="keyword">new</span></span><br><span class="line">  {</span><br><span class="line">    order.Id,</span><br><span class="line">    date = order.Date,</span><br><span class="line">    sumCount = details.Sum(d => d.Count),</span><br><span class="line">    order.State,</span><br><span class="line">    Details = details</span><br><span class="line">  });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(8):实体模型</title>
    <url>/posts/2388793323/</url>
    <content><![CDATA[<p>本案例使用的数据库是：mysql 5.7.8，其它类型数据库也可以，自行辨别需要修改的地方就行了。</p><p>代码优先还是数据库优先，大家可以根据自己的习惯和情况任选，案例中采用了数据库优先。</p><p>数据库 SQL 文件（<a href="https://github.com/buker2012/Zilor.Order/blob/master/asset/zilor_order.sql" target="_blank" rel="noopener">zilor_order.sql</a>）已上传 GitHub ，含表结构与商品数据，需自行创建数据库。</p><a id="more"></a><h2 id="FreeSql"><a href="#FreeSql" class="headerlink" title="FreeSql"></a>FreeSql</h2><p>FreeSql 是一个功能强大的对象关系映射程序(O/RM)，支持 .NETCore 2.1+ 或 .NETFramework 4.0+。</p><p>详细介绍，请见 <a href="https://github.com/2881099/FreeSql" target="_blank" rel="noopener">GitHub</a>.</p><p>FreeSql 提供了五种使用习惯，案例使用 <code>FreeSql.Repository</code> 仓储模式.</p><h2 id="添加-FreeSql-Repository-包"><a href="#添加-FreeSql-Repository-包" class="headerlink" title="添加 FreeSql.Repository 包"></a>添加 FreeSql.Repository 包</h2><p>在 WebApi 项目目录中，运行以下命令</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 FreeSql.Repository 包</span></span><br><span class="line">dotnet add package FreeSql.Repository</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 mysql 驱动包</span></span><br><span class="line">dotnet add package FreeSql.Provider.MySql</span><br></pre></td></tr></tbody></table></figure><p><code>Startup.ConfigureServices</code> 中添加以下代码：</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fsql = <span class="keyword">new</span> FreeSql.FreeSqlBuilder()</span><br><span class="line">    .UseConnectionString(FreeSql.DataType.MySql, Configuration.GetConnectionString(<span class="string">"DefaultConnection"</span>))</span><br><span class="line">    .Build();</span><br><span class="line">services.AddSingleton<ifreesql>(fsql);</ifreesql></span><br></pre></td></tr></tbody></table></figure><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><p>创建 Model 文件夹，并创建以下3个实体类</p><h3 id="商品资料-Goods-cs"><a href="#商品资料-Goods-cs" class="headerlink" title="商品资料 Goods.cs"></a>商品资料 Goods.cs</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">Table(Name = <span class="meta-string">"goods"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Goods</span></span><br><span class="line">{</span><br><span class="line">  [<span class="meta">Column(IsPrimary = true)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Barcode { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Name { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Sort1 { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Sort2 { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Spec { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="订单-OrderPrimary-cs"><a href="#订单-OrderPrimary-cs" class="headerlink" title="订单 OrderPrimary.cs"></a>订单 OrderPrimary.cs</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">Table(Name = <span class="meta-string">"order_primary"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderPrimary</span></span><br><span class="line">{</span><br><span class="line">  [<span class="meta">Column(IsPrimary = true, IsIdentity = true)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">long</span> Id { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">short</span> State { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Date { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"></span><br><span class="line">  [<span class="meta">Column(Name = <span class="meta-string">"created_by"</span>)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> CreatedBy { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"></span><br><span class="line">  [<span class="meta">Column(Name = <span class="meta-string">"created_time"</span>)</span>]</span><br><span class="line">  <span class="keyword">public</span> DateTime CreatedTime { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"></span><br><span class="line">  [<span class="meta">Column(Name = <span class="meta-string">"checked_by"</span>)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> CheckedBy { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"></span><br><span class="line">  [<span class="meta">Column(Name = <span class="meta-string">"checked_time"</span>)</span>]</span><br><span class="line">  <span class="keyword">public</span> DateTime? CheckedTime { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"></span><br><span class="line">  [<span class="meta">Column(IsVersion = true)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">long</span> Version { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="订单明细-OrderDetail-cs"><a href="#订单明细-OrderDetail-cs" class="headerlink" title="订单明细 OrderDetail.cs"></a>订单明细 OrderDetail.cs</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">Table(Name = <span class="meta-string">"order_detail"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderDetail</span></span><br><span class="line">{</span><br><span class="line">  [<span class="meta">Column(IsPrimary = true)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">long</span> Id { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"></span><br><span class="line">  [<span class="meta">Column(IsPrimary = true)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Barcode { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> Count { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
        <tag>FreeSql</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(7):登录认证</title>
    <url>/posts/303245083/</url>
    <content><![CDATA[<p>用户登录认证方案使用 JWT，结合 HTTPS，这种方案非常适合小程序，即安全又简单。</p><a id="more"></a><div class="note default"><p>注意：文章中只贴出核心代码，本案例完整代码都已上传 GitHub。</p></div><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT(JSON Web Token)是一种用来传输JSON对象的安全标准。这里不详细讲解 JWT,有兴趣的可以看这篇文章。</p><a href="/posts/888328336/" title="JSON Web Token 入门教程">JSON Web Token 入门教程</a><p>下面从小程序出发，分别说明登录与认证的详细流程。</p><h2 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h2><p>用户发起请求前，会先检查 Cookies 中是否存在 JWT，如不存在发起登录流程：</p><ol><li>小程序：获取免登授权码 authCode</li><li>小程序：发送 authCode 到 WebApi 服务器</li><li>服务器：获取钉钉开放平台的 access_token</li><li>服务器：通过 authCode 和 access_token 获取用户的钉钉 userid</li><li>服务器：通过 userid 获取工号 jobnumber</li><li>服务器：生成包含 jobnumber 的 JWT</li><li>服务器：返回 JWT</li><li>小程序：将 JWT 存储在 应用缓存(Storage)中</li></ol><p>第1 ~ 2步，是小程序部分，不是我们现在需要关心的；第3 ~ 5步，现在我们也不需要关心。因为我们现在还没有开始编写小程序，拿不到关键的<code>免登授权码</code>，也就无法获得 <code>jobnumber</code>。</p><p>在没有完成小程序之前，我们先将 jobnumber 设置为临时的测试值，以后再来调整。</p><h3 id="Token-控制器"><a href="#Token-控制器" class="headerlink" title="Token 控制器"></a>Token 控制器</h3><p>创建 <code>TokenController</code>，该控制器负责验证 authCode 发放 JWT，以完成登录流程。在此之前，我们需要添加实现 <code>JWT</code> 认证相关的包。</p><ol><li><p>运行以下命令，为 WebApi 项目添加 JWT 认证相关的包。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Microsoft.IdentityModel.Tokens 提供 Token 加密相关的功能</span></span><br><span class="line">dotnet add package Microsoft.IdentityModel.Tokens --version 5.6.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># System.IdentityModel.Tokens.Jwt 提供 JWT 的创建、验证功能</span></span><br><span class="line">dotnet add package System.IdentityModel.Tokens.Jwt --version 5.6.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Zilor.DingTalkApi 封装好的钉钉开放平台 SDK</span></span><br><span class="line">dotnet add package Zilor.DingTalkApi --version 0.0.7-alpha</span><br></pre></td></tr></tbody></table></figure></li><li><p>在 <code>Controllers</code> 中添加控制器，并添加以下代码</p><figure class="highlight c#"><figcaption><span>TokenController</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"api/[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TokenController</span>: <span class="title">ControllerBase</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">private</span> IConfiguration _configuration { <span class="keyword">get</span>;  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依赖注入 IConfiguration 配置接口</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TokenController</span>(<span class="params">DingTalkClient dingTalkClient, Configuration configuration</span>)</span></span><br><span class="line"><span class="function"></span>  {</span><br><span class="line">    _dingTalkClient = dingTalkClient;</span><br><span class="line">    _configuration = configuration;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  [<span class="meta">AllowAnonymous</span>]	<span class="comment">// 设置为 允许匿名访问</span></span><br><span class="line">  [<span class="meta">HttpPost</span>]</span><br><span class="line">  <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Post</span>(<span class="params"><span class="keyword">string</span> authCode</span>)</span></span><br><span class="line"><span class="function"></span>  {</span><br><span class="line">    <span class="comment">// authCode 暂时用不到</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// 获取用户 serid</span></span><br><span class="line">      <span class="comment">// var userid = _dingTalkClient.GetUserId(authCode);</span></span><br><span class="line">      <span class="comment">// 获取用户 jobnumber</span></span><br><span class="line">      <span class="comment">// var jobnumber = _dingTalkClient.GetJobNumber(userid);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 测试用工号</span></span><br><span class="line">      <span class="keyword">var</span> jobnumber = <span class="string">"100001"</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 用户标识</span></span><br><span class="line">      <span class="keyword">var</span> claims = <span class="keyword">new</span>[]</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">new</span> Claim(<span class="string">"jobnumber"</span>, jobnumber)</span><br><span class="line">      };</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加密 jwt 的密钥，需要提供至少 128 位的字符串</span></span><br><span class="line">      <span class="comment">// JwtSecret 保存在 appsettings.json 中，切勿泄露。</span></span><br><span class="line">      <span class="keyword">var</span> key = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration[<span class="string">"JwtSecret"</span>]));</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 使用 HS256 加密算法 </span></span><br><span class="line">      <span class="keyword">var</span> creds = <span class="keyword">new</span> SigningCredentials(key, SecurityAlgorithms.HmacSha256);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 配置 jwt</span></span><br><span class="line">      <span class="keyword">var</span> jwt = <span class="keyword">new</span> JwtSecurityToken(</span><br><span class="line">          issuer: <span class="string">"Zilor"</span>,		    <span class="comment">// 发放者，随意填写，验证时需要</span></span><br><span class="line">          audience: <span class="string">"Zilor"</span>,	    <span class="comment">// 接受者，随意填写，验证时需要</span></span><br><span class="line">          claims: claims,			    <span class="comment">// 用户标识</span></span><br><span class="line">          expires: DateTime.Now.AddDays(<span class="number">15</span>),	<span class="comment">// 过期时间，15天后</span></span><br><span class="line">          signingCredentials: creds     <span class="comment">//加密算法</span></span><br><span class="line">      );</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 生成 jwt</span></span><br><span class="line">      <span class="keyword">var</span> token = <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(jwt);</span><br><span class="line">      <span class="keyword">return</span> Ok(<span class="keyword">new</span> {token});</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    { </span><br><span class="line">      <span class="comment">// 发生异常，则登录失败，可以返回401、404</span></span><br><span class="line">      <span class="comment">// 设置用户敏感信息强制显示，否则即使是DEBUG中出了错，也会看不见异常</span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">      IdentityModelEventSource.ShowPII = <span class="literal">true</span>;</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">return</span> BadRequest(ex.Message);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><ol><li>小程序：从 Storage 中获取 JWT</li><li>小程序：将 JWT 放在请求头 Authorization 中</li><li>服务器：收到小程序请求，读取请求头 Authorization 中的 JWT</li><li>服务器：验证 JWT 是否合法，不合法返回 401</li><li>服务器：解析合法 JWT，获取其中的 jobnumber</li></ol><p>认证也是一样，直接从第3步开始</p><h3 id="认证中间件"><a href="#认证中间件" class="headerlink" title="认证中间件"></a>认证中间件</h3><ol><li><p><code>Startup.ConfigureServices</code> 中添加以下代码：</p><figure class="highlight c#"><figcaption><span>Startup.ConfigureServices</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  services.AddControllers();</span><br><span class="line">  <span class="comment">// Swagger 配置 ... </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加 HttpContextAccessor，这样就可以注入控制器 使用 HttpContext</span></span><br><span class="line">  <span class="comment">// HttpContext 可以获取当前认证通过的用户信息</span></span><br><span class="line">  services.AddHttpContextAccessor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//钉钉客户端 SDK 配置</span></span><br><span class="line">  <span class="keyword">var</span> appkey = Configuration.GetSection(<span class="string">"DingTalk:Appkey"</span>).Value;</span><br><span class="line">  <span class="keyword">var</span> appsecret = Configuration.GetSection(<span class="string">"DingTalk:Appsecret"</span>).Value;</span><br><span class="line">  services.AddDingTalk(appkey, appsecret);</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">region</span> JWT 认证配置</span></span><br><span class="line">  <span class="comment">// 添加认证方式 JwtBearerDefaults，其值为 “Bearer” </span></span><br><span class="line">  services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><br><span class="line">          .AddJwtBearer(options =></span><br><span class="line">          {</span><br><span class="line">            options.TokenValidationParameters = <span class="keyword">new</span> TokenValidationParameters</span><br><span class="line">            {</span><br><span class="line">              ValidIssuer = <span class="string">"Zilor"</span>,        <span class="comment">// 待验证发放者，与 TokenController 里的要一致</span></span><br><span class="line">              ValidAudience = <span class="string">"Zilor"</span>,      <span class="comment">// 待验证接受者，与 TokenController 里的要一致</span></span><br><span class="line">              <span class="comment">// 签名加密 key，即 JWT 密钥，与 TokenController 里的要一致</span></span><br><span class="line">              IssuerSigningKey = <span class="keyword">new</span> SymmetricSecurityKey(</span><br><span class="line">                    Encoding.UTF8.GetBytes(Configuration[<span class="string">"JwtSecret"</span>])),</span><br><span class="line">                    </span><br><span class="line">              ValidateIssuer = <span class="literal">true</span>,          <span class="comment">// 验证 发放者</span></span><br><span class="line">              ValidateAudience = <span class="literal">true</span>,        <span class="comment">// 验证 接受者</span></span><br><span class="line">              ValidateLifetime = <span class="literal">true</span>,        <span class="comment">// 验证 到期时间</span></span><br><span class="line">              ValidateIssuerSigningKey = <span class="literal">true</span>  <span class="comment">// 验证 签名</span></span><br><span class="line">            };</span><br><span class="line">          });</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>AddJwtBearer 会在 IServiceCollection 中添加 <code>JwtBearerHandler</code> 类，它可以自己提取 Request 的 <code>Authorization</code> 头信息，验证值是否以 <code>Bearer</code> 开头，然后获得加密后的 JWT，对其进行解密验证。</p><p>如果 JWT 验证合法，他会提取用户信息填充到<code>HttpContext.User</code>中，所以我们要注入<code>HttpContextAccessor</code>，这样就可以在控制器中，通过依赖注入获得<code>HttpContext.User</code>，得到在用户登录时，设置好的用户信息。</p></li><li><p><code>Startup.Configure</code> 中添加以下代码:</p><figure class="highlight c#"><figcaption><span>Startup.Configure</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">  <span class="comment">// 其它配置</span></span><br><span class="line">  <span class="comment">// Swagger 配置 ... </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启用认证</span></span><br><span class="line">  app.UseAuthentication();</span><br><span class="line">  <span class="comment">// 启用授权</span></span><br><span class="line">  app.UseAuthorization();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其它配置 ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(6):Swagger</title>
    <url>/posts/2656483526/</url>
    <content><![CDATA[<p><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 也称为 <a href="https://www.openapis.org/" target="_blank" rel="noopener">OpenAPI</a>，它解决了为 Web API 生成有用文档和帮助页的问题。 它具有诸如交互式文档、客户端 SDK 生成和 API 可发现性等优点。</p><p>说白了，它可以为我们的 WebAPI 提供了文档说明页面，并且可以进行简单的 API 调用测试。</p><a id="more"></a><h2 id="添加-Swagger"><a href="#添加-Swagger" class="headerlink" title="添加 Swagger"></a>添加 Swagger</h2><ol><li><p>运行以下命令，添加 Swashbuckle.AspNetCore 包</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到项目目录</span></span><br><span class="line"><span class="built_in">cd</span> zilor.Order.WebApi</span><br><span class="line"><span class="comment"># 添加 Swashbuckle.AspNetCore 包</span></span><br><span class="line">dotnet add package Swashbuckle.AspNetCore --version 5.0.0-rc4</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改项目文件，启用 xml 注释文档，提供给 swagger 使用</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-5-%E5%88%9B%E5%BB%BA%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%5D-2019-10-27-10-52-46.png" alt></p></li><li><p>在 Startup 类中，导入以下命名空间：</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.OpenApi.Models;</span><br></pre></td></tr></tbody></table></figure></li><li><p>将 Swagger 生成器添加到 Startup.ConfigureServices 方法中的服务集合中</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    services.AddControllers();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 Swagger 生成器添加到 Startup.ConfigureServices 方法中的服务集合中</span></span><br><span class="line">    services.AddSwaggerGen(c =></span><br><span class="line">    {</span><br><span class="line">        c.SwaggerDoc(<span class="string">"v1"</span>, <span class="keyword">new</span> OpenApiInfo</span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">            Title = <span class="string">"订单采集小程序 API"</span>,</span><br><span class="line">            Version = <span class="string">"v1"</span></span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> xmlFile = <span class="string">$"<span class="subst">{Assembly.GetExecutingAssembly().GetName().Name}</span>.xml"</span>;</span><br><span class="line">        <span class="keyword">var</span> xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);</span><br><span class="line">        c.IncludeXmlComments(xmlPath);</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>在 Startup.Configure 方法中，启用中间件为生成的 JSON 文档和 Swagger UI 提供服务</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  app.UseSwagger();</span><br><span class="line">  app.UseSwaggerUI(c =></span><br><span class="line">  {</span><br><span class="line">      c.SwaggerEndpoint(<span class="string">"/swagger/v1/swagger.json"</span>, <span class="string">"订单采集小程序 API V1"</span>);</span><br><span class="line">  });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="使用-swagger"><a href="#使用-swagger" class="headerlink" title="使用 swagger"></a>使用 swagger</h2><ol><li><p>在控制器上添加 xml 注释</p><p>安装 vs code 插件 <code>C# XML Documentation Comments</code>，可以通过输入<code>///</code>快速添加 xml 注释。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-6-Swagger%5D-2019-10-27-11-24-12.png" alt></p></li></ol><ol start="2"><li><p>按下键盘上的 F5，调试运行项目，导航到 <code>https://localhost:5001/swagger</code> 地址，可以看到当前项目所有 API 接口的说明。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-5-%E5%88%9B%E5%BB%BA%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%5D-2019-10-27-11-5-59.png" alt></p></li><li><p>点击接口可以展开，查看更详细的信息，还可以直接调用接口，进行测试。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-6-Swagger%5D-2019-10-27-11-33-46.png" alt></p></li></ol><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(5):解决方案</title>
    <url>/posts/3008954784/</url>
    <content><![CDATA[<p>我们这个案例分为前端小程序和后端 Web API 两个项目。虽然先做哪个都可以，但是惯例上来说，一般是先后再前。</p><h2 id="dotnet"><a href="#dotnet" class="headerlink" title="dotnet"></a>dotnet</h2><p>使用 vs code 作为开发工具，必须使用 dotnet 命令，在命令行环境下才能创建 ASP.NEW Web API 项目。</p><a id="more"></a><p>首先安装 <a href="https://dotnet.microsoft.com/download" target="_blank" rel="noopener">.NET Core 3.0 SDK</a> ，如果你已经安装了最新的 vs 2019，那么就不需要这一步了。安装过程过于简单，不再描述。</p><p>打开命令行工具，输入以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">dotnet --info</span><br></pre></td></tr></tbody></table></figure><p>看看是否成功，版本是否正确：</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/20191025152310.png" alt></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>创建文件夹<code>Zilor.Order</code></p></li><li><p>在 vs code 中打开它</p></li><li><p>打开终端（<code>Ctrl + ~</code>），运行以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 创建解决方案</span></span><br><span class="line">dotnet new sln</span><br><span class="line"><span class="comment"># 创建 ASP.NET Core WebApi 项目</span></span><br><span class="line">dotnet new webapi -n zilor.Order.WebApi</span><br><span class="line"><span class="comment"># 添加 WebApi 项目到解决方案中</span></span><br><span class="line">dotnet sln Zilor.Order.sln add zilor.Order.WebApi/zilor.Order.WebApi.csproj</span><br></pre></td></tr></tbody></table></figure></li></ol><p>新创建的 WebApi 项目，默认添加了一个 <code>WeatherForecast</code> 控制器，相当于 Hello World。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-5-%E5%88%9B%E5%BB%BA%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%5D-2019-10-27-11-9-37.png" alt></p><p>如果你是第一次用 vs code 打开 .Net Core 工程目录，那么随便打开一个 .cs 文件，右下角会弹出类似下图的询问框。它在问你要不要安装支持 C# 的插件和 Debug 配置文件，一律 Yes 即可。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/20191025153605.png" alt></p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(4):接口设计</title>
    <url>/posts/771724912/</url>
    <content><![CDATA[<p>Web API 接口是前端和后端通讯的主要方式，所以在做前后端分离的项目时，需要先设计好 API 接口。</p><p>尤其是当前端和后端的开发人员不是同一个人时，那么在编码前，就必须约定好接口规范。否则，你做你的，我做我的，最后发现对接不上，那就很糟糕了。</p><a id="more"></a><p>即便这篇教程里的案例很简单，我也仍然建议大家先把接口设计好，这样就不会在编码时找不到方向，随性而为，甚至写着写着，接口就偏离了设计。</p><h2 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h2><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p><strong>简要描述</strong></p><ul><li>使用钉钉免登授权码换取token，除了该接口，其它接口都需要使用 token 验证身份。</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/token</li></ul><p><strong>请求方式</strong></p><ul><li>POST</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>authCode</td><td>是</td><td>string</td><td>钉钉免登授权码</td></tr></tbody></table><p><strong>返回正确示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"token"</span>: <span class="string">"abcd*****efg"</span> <span class="comment">// JWT</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="商品资料相关"><a href="#商品资料相关" class="headerlink" title="商品资料相关"></a>商品资料相关</h2><h3 id="商品资料查询"><a href="#商品资料查询" class="headerlink" title="商品资料查询"></a>商品资料查询</h3><p><strong>简要描述</strong></p><ul><li>按商品条码查询商品资料</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/goods</li></ul><p><strong>请求方式</strong></p><ul><li>GET</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>barcode</td><td>是</td><td>string</td><td>商品条码</td></tr></tbody></table><p><strong>返回正确示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"barcode"</span>: <span class="number">1000000001</span>, <span class="comment">// 商品条码</span></span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"可口可乐"</span>, <span class="comment">// 商品名称</span></span><br><span class="line">  <span class="string">"sort1"</span>: <span class="string">"饮料"</span>, <span class="comment">// 商品类别1</span></span><br><span class="line">  <span class="string">"sort2"</span>: <span class="string">"碳酸饮料"</span>, <span class="comment">// 商品类别2</span></span><br><span class="line">  <span class="string">"spec"</span>: <span class="string">"24*200ml"</span> <span class="comment">// 商品规格</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="订单相关"><a href="#订单相关" class="headerlink" title="订单相关"></a>订单相关</h2><h3 id="历史订单查询"><a href="#历史订单查询" class="headerlink" title="历史订单查询"></a>历史订单查询</h3><p><strong>简要描述</strong></p><ul><li>查询用户历史订单，默认查询前20条</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order</li></ul><p><strong>请求方式</strong></p><ul><li>GET</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>pageIndex</td><td>否</td><td>int</td><td>页码，默认查询第 1 页</td></tr><tr><td>state</td><td>否</td><td>int</td><td>查询订单状态：0、未确认；1、已确认；-1、全部</td></tr></tbody></table><p><strong>返回正确示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">1000000001</span>, <span class="comment">// 订单编号</span></span><br><span class="line">    <span class="string">"date"</span>: <span class="string">"2019-09-30"</span>, <span class="comment">// 订单日期</span></span><br><span class="line">    <span class="string">"sumCount"</span>: <span class="number">100</span>, <span class="comment">// 订单商品数量</span></span><br><span class="line">    <span class="string">"state"</span>: <span class="number">0</span> <span class="comment">// 状态，0、未确认，1、已确认</span></span><br><span class="line">  },</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h3 id="订单查询"><a href="#订单查询" class="headerlink" title="订单查询"></a>订单查询</h3><p><strong>简要描述</strong></p><ul><li>按订单编号查询订单及明细</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order/{id}</li></ul><p><strong>请求方式</strong></p><ul><li>GET</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>long</td><td>订单编号</td></tr></tbody></table><p><strong>返回正确示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"id"</span>: <span class="number">1000000001</span>, <span class="comment">// 订单编号</span></span><br><span class="line">  <span class="string">"date"</span>: <span class="string">"2019-09-30"</span>, <span class="comment">// 订单日期</span></span><br><span class="line">  <span class="string">"sumCount"</span>: <span class="number">123</span>, <span class="comment">// 订单商品总数量</span></span><br><span class="line">  <span class="string">"state"</span>: <span class="number">0</span> <span class="comment">// 状态，0、未确认，1、已确认</span></span><br><span class="line">  <span class="string">"details"</span>: [</span><br><span class="line">    { </span><br><span class="line">      <span class="string">"barcode"</span>: <span class="string">"123456789"</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"可口可乐"</span>,</span><br><span class="line">      <span class="string">"sort1"</span>: <span class="string">"饮料"</span>,</span><br><span class="line">      <span class="string">"sort2"</span>: <span class="string">"碳酸饮料"</span>,</span><br><span class="line">      <span class="string">"spec"</span>: <span class="string">"100g*8*9"</span>,</span><br><span class="line">      <span class="string">"count"</span>: <span class="number">123</span> </span><br><span class="line">    },</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><h3 id="订单添加"><a href="#订单添加" class="headerlink" title="订单添加"></a>订单添加</h3><p><strong>简要描述</strong></p><ul><li>添加新的订单</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order</li></ul><p><strong>请求方式</strong></p><ul><li>POST</li></ul><p><strong>请求参数</strong></p><ul><li>无</li></ul><p><strong>返回正确示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"id"</span>: <span class="number">1</span>, <span class="comment">// 订单编号</span></span><br><span class="line">  <span class="string">"date"</span>: <span class="string">"2019-09-30"</span> <span class="comment">// 订单日期</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="订单日期修改"><a href="#订单日期修改" class="headerlink" title="订单日期修改"></a>订单日期修改</h3><p><strong>简要描述</strong></p><ul><li>修改指定编号订单日期，只能修改状态为「未确认」订单</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order</li></ul><p><strong>请求方式</strong></p><ul><li>PUT</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>long</td><td>要修改的订单编号</td></tr><tr><td>date</td><td>否</td><td>string</td><td>订单日期，格式：“yyyy-MM-dd”，例：“2019-09-30”</td></tr></tbody></table><p><strong>返回正确示例</strong></p><p>无</p><h3 id="订单删除"><a href="#订单删除" class="headerlink" title="订单删除"></a>订单删除</h3><p><strong>简要描述</strong></p><ul><li>删除指定编号订单，包括订单明细</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order</li></ul><p><strong>请求方式</strong></p><ul><li>DELETE</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>long</td><td>订单编号</td></tr></tbody></table><p><strong>返回正确示例</strong></p><ul><li>无</li></ul><h2 id="订单明细相关"><a href="#订单明细相关" class="headerlink" title="订单明细相关"></a>订单明细相关</h2><h3 id="订单明细添加"><a href="#订单明细添加" class="headerlink" title="订单明细添加"></a>订单明细添加</h3><p><strong>简要描述</strong></p><ul><li>添加订单商品明细</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order-detail</li></ul><p><strong>请求方式</strong></p><ul><li>POST</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>long</td><td>订单编号</td></tr><tr><td>barcode</td><td>是</td><td>string</td><td>商品条码</td></tr><tr><td>count</td><td>是</td><td>int</td><td>商品数量</td></tr></tbody></table><p><strong>返回正确示例</strong></p><ul><li>无</li></ul><h3 id="订单明细修改"><a href="#订单明细修改" class="headerlink" title="订单明细修改"></a>订单明细修改</h3><p><strong>简要描述</strong></p><ul><li>修改订单明细数量</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order-detail</li></ul><p><strong>请求方式</strong></p><ul><li>PUT</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>long</td><td>订单变好</td></tr><tr><td>barcode</td><td>是</td><td>string</td><td>商品条码</td></tr><tr><td>count</td><td>是</td><td>int</td><td>商品数量</td></tr></tbody></table><p><strong>返回正确示例</strong></p><ul><li>无</li></ul><h3 id="订单明细删除"><a href="#订单明细删除" class="headerlink" title="订单明细删除"></a>订单明细删除</h3><p><strong>简要描述</strong></p><ul><li>删除订单的商品明细，需要鉴权</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order-detail</li></ul><p><strong>请求方式</strong></p><ul><li>DELETE</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>long</td><td>订单编号</td></tr><tr><td>barcode</td><td>是</td><td>string</td><td>商品条码</td></tr></tbody></table><p><strong>返回正确示例</strong></p><ul><li>无</li></ul><h2 id="全局错误状态码"><a href="#全局错误状态码" class="headerlink" title="全局错误状态码"></a>全局错误状态码</h2><table><thead><tr><th>HTTP 状态码</th><th>名称</th><th>错误解释</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>一般性异常错误</td></tr><tr><td>401</td><td>Unauthorized</td><td>未授权，Token 认证错误</td></tr><tr><td>404</td><td>Not Found</td><td>请求的资源未找到</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误</td></tr></tbody></table><p>如有具体错误消息，放在消息体的 msg 中，示例：</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"msg"</span>: <span class="string">"这是具体的错误原因"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(3):架构设计</title>
    <url>/posts/1868140162/</url>
    <content><![CDATA[<p>或许会有人觉得很奇怪，这么芝麻小点的项目，还需要进行架构设计吗？</p><a id="more"></a><p>其实所谓的架构设计，并不是什么高深莫测东西，无论你是否了解，它确实的存在于我们软件开发过程中的各个环节中。哪怕你没有专门去做过架构设计，但你在构想项目时，就已经悄无声息的把它包含了进去。</p><p>比如，你至少考虑过技术选型；稍微深入一点的话，或许你还考虑过是使用三层架构还是五层架构等等；如果更深入一些的话，或许还考虑过数据建模、DDD 之类的。</p><p>这些想法，无论是否落在纸面上，都是在进行架构设计，或者说是架构设计的一部分。每一个开发工程师，都是架构师的种子。这也是为什么大多数优秀的架构师，都是从经验丰富的开发工程师一路升级而来。</p><p>麻雀虽小五脏俱全，接下来，用几张简单易懂的 C4 模型图，简要阐明这个项目的架构设计。</p><blockquote><p>如果对“C4 模型”感兴趣的同学，可以看一下这篇文章：<a href="https://www.infoq.cn/article/C4-architecture-model" target="_blank" rel="noopener">用于软件架构的 C4 模型</a>。不想看长篇大论的话，那这里就用一句话概括：C4 模型是一种简单、直观、易于被各层次开发人员、业务人员所理解的架构设计图。</p></blockquote><h3 id="C4-语境图"><a href="#C4-语境图" class="headerlink" title="C4 语境图"></a>C4 语境图</h3><p>语境图是用来表明项目所处的场景，与哪些外部系统有关联。由于我们这个项目的场景非常简单，语境图的意义不大，就略过了，直接看容器图。</p><h3 id="C4-容器图"><a href="#C4-容器图" class="headerlink" title="C4 容器图"></a>C4 容器图</h3><p>容器图简单来说，是语境图的放大，它可以帮助了解组成项目各个部分的技术选型，以及它们的关系。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-3-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-31-10-22-3.jpg" alt></p><p>由此图可见，我们的用户主体是【业务员】；用户通过钉钉访问小程序【订单采集】，Web API 应用为其提供数据功能接口；由于使用的是钉钉内部登录，所以需要外部系统【钉钉开发平台】的支持。</p><h3 id="C4-组件图"><a href="#C4-组件图" class="headerlink" title="C4 组件图"></a>C4 组件图</h3><p>组件图是将容器图中的应用进一步放大，它可以帮助我们了解应用的组成部分（组件），以及各个组件之间的关系。我们的实际开发，也是以此图为引导进行。</p><p>注意：这并不是UML类图，它比类图要更加抽象一些，也更加容易理解。</p><h4 id="钉钉应用-组件图"><a href="#钉钉应用-组件图" class="headerlink" title="钉钉应用 组件图"></a>钉钉应用 组件图</h4><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-3-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-31-10-24-16.jpg" alt></p><h4 id="Web-API-应用-组件图"><a href="#Web-API-应用-组件图" class="headerlink" title="Web API 应用 组件图"></a>Web API 应用 组件图</h4><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-3-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-31-10-24-39.jpg" alt></p><p>这么个简单的小项目用不到复杂的架构，所以这里采用了 FreeSQL 作为 ORM 框架，其中 FreeSQL.Repository 可以直接作为我们的仓储层；然后只需要封装下钉钉开放平台客户端，就可以直接在控制器里写业务了</p><h3 id="数据库模型"><a href="#数据库模型" class="headerlink" title="数据库模型"></a>数据库模型</h3><p>极简设计，三张表足矣。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-3-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-31-10-28-10.png" alt></p><h4 id="商品资料"><a href="#商品资料" class="headerlink" title="商品资料"></a>商品资料</h4><p>简易版的商品资料，原系统的商品资料表有二十多个字段，我进行了简化，这里并不是重点。</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BASP-NET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%A2%E5%8D%95%E9%87%87%E9%9B%86%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-23-16-30-44-image-20191020191338848.png" alt="[ASP-NET-Core-3-0-项目实战之订单采集小程序-第三章-架构设计]-2019-10-23-16-30-44-image-20191020191338848.png"><h4 id="主订单"><a href="#主订单" class="headerlink" title="主订单"></a>主订单</h4><p>订单其实是两个表：</p><ol><li>「主订单」记录订单的主要数据，比如订单编号、订单状态、创建时间、创建人等；</li><li>「订单明细」记录订单中的商品明细，字段「id」和 「barcode」为联合主键。</li></ol><p>需要注意：用户创建订单后，订单状态「state」默认为「0」，即「未确认」。后台审核后，「state」更新为「1」，即「已确认」。这个案例，不包含后台业务，我们只需要查出其值即可。</p><center>主订单</center><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-3-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-28-15-32-6.png" alt></p><center>订单明细</center><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-3-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-31-10-30-48.png" alt></p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(2):需求分析</title>
    <url>/posts/3510016629/</url>
    <content><![CDATA[<p>做任何项目前，无论大小，都应该养成需求分析的习惯。这个分析不一定要非常细致，但要尽量全面。</p><p>为什么说不要求非常细致？</p><a id="more"></a><p>因为在实际的开发中，需求总是会变化。细致的需求分析不仅耽误时间，也会陷入钻牛角的情况，若以后需求有了变化，那样不仅白白做了工，很多东西或许还要推倒重来。但也不能因此什么都不做，我见过许多初中级开发人员，拿到一纸需求后，追求效率，略微在大脑里构想一遍，就开始动手 coding 了。</p><p>虽然这样有时候很快，但也有不少时候由于分析的不到位，或者说，由于没有落到文档上形成参考标准，导致在开发时，自己的构想不断变化，反复推倒自己的代码，进而造成效率低下。</p><p>记住，慢就是快。在进行需求分析时，我倾向于从用户角度出发，这样不仅理清了需求，甚至连业务流程也能包含进来。虽然不够详细，但作为指导方向是很不错的，同时也可以帮助我们对业务更加熟悉。</p><h3 id="需求概述"><a href="#需求概述" class="headerlink" title="需求概述"></a>需求概述</h3><ul><li>业务场景：业务员外出采购时，通过钉钉来提交、管理采购订单。订单内容包括商品资料、采购数量、采购日期、审核日期、状态、采购人（业务员）。</li><li>功能需求：历史订单查询、订单明细查询、订单录入、订单修改、订单删除</li></ul><h4 id="历史订单查询"><a href="#历史订单查询" class="headerlink" title="历史订单查询"></a>历史订单查询</h4><ul><li>业务描述：默认查询用户的最近 20 条历史订单记录，可以查看更多历史订单，筛选订单状态（已确认、未确认）。</li><li>功能描述：<ol><li>用户登录后跳转到【我的订单】页面，查询用户订单；</li><li>该页面为订单列表，显示日期、数量、订单号、状态四列内容；</li><li>点击【状态】列头，可以选择订单状态。</li></ol></li></ul><h4 id="订单明细查询"><a href="#订单明细查询" class="headerlink" title="订单明细查询"></a>订单明细查询</h4><ul><li>业务描述：查询订单中的包含的所有商品资料（条码、名称、类别、数量），订单的基本资料（日期、数量、订单号、状态）。</li><li>功能描述：<ol><li>用户点击【我的订单】列表中的订单号，跳转到【订单明细】页面；</li><li>该页面显示订单的基本资料与商品列表。</li></ol></li></ul><h4 id="订单录入"><a href="#订单录入" class="headerlink" title="订单录入"></a>订单录入</h4><ul><li>业务描述：录入的新增订单默认日期为当日，订单中可以添加商品；商品添加只需要输入商品条码，自动读取商品资料；新订单的状态为未确认。</li><li>功能描述：<ol><li>用户点击【我的订单】列表中的【创建新订单】按钮，跳转到【新增订单】页面；</li><li>订单默认日期为当日，默认状态为【未确认】；</li><li>点击【添加商品】按钮，弹出商品录入表单，用户输入条码后，查询该条码的商品资料，并回填到表单中，供用户确认；</li><li>确认商品资料，填入数量；</li><li>单击商品记录弹出商品资料表单，可以修改数量、删除商品；</li></ol></li></ul><h4 id="订单修改"><a href="#订单修改" class="headerlink" title="订单修改"></a>订单修改</h4><ul><li>业务描述：用户只能修改状态为“未确认”的订单；只能修改订单的“日期”与商品明细。</li><li>功能描述：<ol><li>用户点击【我的订单】列表中【未确认】状态列，跳转到【订单修改】页面；</li><li>载入【订单修改】页面，查询目标订单的所有数据；</li><li>订单商品明细的添加、删除、修改与【订单录入】模块的逻辑相同；</li></ol></li></ul><h4 id="订单删除"><a href="#订单删除" class="headerlink" title="订单删除"></a>订单删除</h4><ul><li>业务描述：用户只能删除状态为“未确认”的订单，已确认订单不可删除。</li><li>功能描述：<ol><li>用户点击【我的订单】列表中【未确认】状态列，跳转到【订单修改】页面；</li><li>查询目标订单的所有数据，并载入【订单修改】页面；</li><li>点击【删除订单】按钮，弹出确认删除提示框，再次点击“删除”按钮，将该订单永久删除。</li></ol></li></ul><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(1):项目概述</title>
    <url>/posts/2337956806/</url>
    <content><![CDATA[<p>此案例是某 ERP 系统中的一个相对独立的SOA模块，因为这个 ERP 系统使用的技术相对来说比较老了，故而将其抽离出来，使用 ASP.NET Core 3.0 进行重构。</p><a id="more"></a><p>由于把这个模块从原系统中抽离了出来，自然也剥离了一些业务，所以简化了不少，功能也就简单多了。依然是以增删改查为核心，并没有什么难度，也没有什么高并发的需求，所以这篇教程比较适合接触过 .NET Core 的朋友。</p><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>『订单采集』一个是作为『企业内部应用』运行在钉钉中的小程序，用户对象是企业内部员工（业务员）。</p><p>业务员外出采购时，在钉钉里使用『订单采集』提交、管理自己的采购订单，订单的数据存放在 ERP 业务数据库里，由上级进行审批。不过，这个项目只有『订单采集』小程序的部分，审批流程在 ERP 系统中。</p><p>使用钉钉的好处是可以利用钉钉开放平台，由小程序拉取钉钉通讯录，读取用户工号等基本用户信息，实现无感登录。这对于中小型公司来说，免去了 CRM 系统的建设。</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>.NET Core 最大的特性就是跨平台，所以为了体验它的跨平台特性，索性就从跨平台开发开始。</p><p>本案例的系统环境为 Mac OS Catalina(10.15)，所用到的开发工具也全部采用支持跨平台的，以保证在 Windows 系统下具有一致性操作。</p><h3 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h3><p>虽然宇宙第一 IDE（Visual Studio）也有 Mac 版本，但是用起来还是与 Windows 版本有很大差距，真的很不好用。所以，我选择了 Visual Studio Code。</p><p>钉钉开放平台提供的 『小程序开发者工具』，也同样支持跨平台，Mac 版本和 Win 版本完全一样。</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>本案例采用 MySql 作为数据库，版本 5.7 及以上即可。当然，大家也可以使用其它的主流关系型数据库，基本上不需要什么改动。</p><p>数据库管理工具则使用 Navicat，还有什么比它更简单好用的可视化跨平台数据库管理工具呢？反正我不知道，如果你知道，请告诉我！</p><h4 id="源代码管理"><a href="#源代码管理" class="headerlink" title="源代码管理"></a>源代码管理</h4><p>本案例的代码与数据库，已上传 GitHub。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>接口自动化测试工具 Postman，API 文档工具 swagger 也可以进行简单的接口测试。</p><h4 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h4><p>API 应用、数据库、缓存、Web 服务器均采用 Linux 环境下的 Docker 化部署。</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul><li>ASP.NET Core 3.0 Web API</li><li>FreeSql</li><li>MySql</li><li>钉钉小程序</li><li>swagger</li><li>Docker</li><li>Git</li></ul><blockquote><p>该篇文章会随着教程进度更新</p></blockquote><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><p>未完待续</p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>创建nuget包极简教程</title>
    <url>/posts/542292805/</url>
    <content><![CDATA[<p>发布一个 nuget 包非常容易，简单来说只需要三步：设置属性、创建包、发布包。这一篇极简教程，省去了很多细节，但绝对简单。下面我们看看具体如何做。</p><p>如果没有 nuget 账号，去<a href="https://www.nuget.org/" target="_blank" rel="noopener">官网</a>注册先。</p><a id="more"></a><h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><p>假设你有一个名为 MyPackage 的类库。</p><p>创建包需要以下属性。</p><ul><li>PackageId，包标识符，在托管包的库中必须是唯一的。如果未指定，默认值为 AssemblyName。</li><li>Version，窗体 Major.Minor.Patch[-Suffix] 中特定的版本号，其中 -Suffix 标识预发布版本 。如果未指定，默认值为 1.0.0。</li><li>Authors，作者和所有者信息。如果未指定，默认值为 AssemblyName。</li><li>Company，公司名称。如果未指定，默认值为 AssemblyName。</li></ul><p>首先，在项目文件 (MyPackage.csproj) 的<code>PropertyGroup</code>节点中添加以下属性：</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%9B%E5%BB%BAnuget%E5%8C%85%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B%5D-2019-10-26-14-5-7.png" alt></p><h3 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h3><ol><li><p>在命令行工具中运行以下命令，先生成二进制文件：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">dotnet build -c Release</span><br></pre></td></tr></tbody></table></figure></li><li><p>然后打包:</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">dotnet pack -o nupkgs -c Release</span><br></pre></td></tr></tbody></table></figure><p>看看项目的 nupkgs 目录下，是不是多了一个 MyPackage.nupkg 文件</p></li></ol><h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><ol><li><p><a href="https://docs.microsoft.com/zh-cn/nuget/nuget-org/scoped-api-keys#acquire-an-api-key" target="_blank" rel="noopener">获取 Nuget API 密钥</a></p></li><li><p>在命令行工具中处运行以下命令，将 <code><你的密钥></code> 替换为从 nuget.org 获取的密钥：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">nuget setApiKey <你的密钥></span><br><span class="line"><span class="comment"># 此命令将 API 密钥存储在本台计算机的 NuGet 配置中，以后就不用再配置了。</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>使用以下命令将包推送到 NuGet 库：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">nuget push nupkgs/MyPackage.nupkg -Source https://api.nuget.org/v3/index.json</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>登录 nuget 账号，通过菜单进入 Manage Packages 页面，就可以看到你刚刚推送的包了。</p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>Nuget</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON Web Token 入门教程</title>
    <url>/posts/888328336/</url>
    <content><![CDATA[<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072301.jpg" alt></p><h2 id="跨域认证的问题"><a href="#跨域认证的问题" class="headerlink" title="跨域认证的问题"></a>跨域认证的问题</h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p><div class="note success"><ol><li><p>用户向服务器发送用户名和密码。</p></li><li><p>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p></li><li><p>服务器向用户返回一个 session_id，写入用户的 Cookie。</p></li><li><p>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p></li><li><p>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></li></ol></div><a id="more"></a><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"姓名"</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="attr">"角色"</span>: <span class="string">"管理员"</span>,</span><br><span class="line">  <span class="attr">"到期时间"</span>: <span class="string">"2018年7月1日0点0分"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h2><p>实际的 JWT 大概就像下面这样。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072304.jpg" alt></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><div class="note success"><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul></div><p>写成一行，就是下面的样子。</p><p><code>Header.Payload.Signature</code></p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg" alt></p><p>下面依次介绍这三个部分。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，<code>alg</code> 属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code> 属性表示这个令牌（token）的类型（type），JWT 令牌统一写为 <code>JWT</code>。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><div class="note success"><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></div><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">"."</span> + base64UrlEncode(payload), secret)</span><br></pre></td></tr></tbody></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><h3 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h2 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息 <code>Authorization</code> 字段里面。</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">Authorization: Bearer <token></token></span><br></pre></td></tr></tbody></table></figure><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h2><ol><li><p>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p></li><li><p>JWT 不加密的情况下，不能将秘密数据写入 JWT。</p></li><li><p>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p></li><li><p>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p></li><li><p>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p></li><li><p>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p></li></ol><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装常用服务</title>
    <url>/posts/1270001210/</url>
    <content><![CDATA[<p>仅记录开发环境下的各服务安装记录，并不适合生产环境。</p><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 下载 mysql 镜像</span></span><br><span class="line">docker pull mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器，并设置为开机启动</span></span><br><span class="line">docker run --name mysql --restart=always -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录mysql</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 下载 Redis 镜像</span></span><br><span class="line">docker pull mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器，并设置为开机启动</span></span><br><span class="line">docker run --name redis --restart=always -p 6379:6379 -d redis redis-server --appendonly yes</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>一个故事告诉你什么是消息队列</title>
    <url>/posts/1805459380/</url>
    <content><![CDATA[<p>挺有意思的，有兴趣可以看看。</p><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>有一天，产品跑来说：“我们要做一个用户注册功能，需要在用户注册成功后给用户发一封成功邮件。”</p><p>小明（攻城狮）：“好，需求很明确了。” 不就提供一个注册接口，保存用户信息，同时发起邮件调用，待邮件发送成功后，返回用户操作成功。没一会功夫，代码就写完了。验证功能没问题后，就发布上线了。</p><p>线上正常运行了一段时间，产品匆匆地跑来说：“你做的功能不行啊，运营反馈注册操作响应太慢，已经有好多用户流失了。”</p><p>小明听得一身冷汗，赶紧回去改。他发现，原先的以单线程同步阻塞的方式进行邮件发送，确实存在问题。这次，他利用了 JAVA 多线程的特性，另起线程进行邮件发送，主线程直接返回保存结果。测试通过后，赶紧发布上线。小明心想，这下总没问题了吧。</p><p>没过多久，产品又跑来了，他说：“现在，注册操作响应是快多了。但是又有新的问题了，有用户反应，邮件收不到。能否在发送邮件时，保存一下发送的结果，对于发送失败的，进行补发。”</p><p>小明一听，哎，又得熬夜加班了。产品看他一脸苦逼的样子，忙说：“邮件服务这块，别的团队都已经做好了，你不用再自己搞了，直接用他们的服务。”</p><p>小明赶紧去和邮件团队沟通，谁知他们的服务根本就不对外开放。这下小明可开始犯愁了，明知道有这么一个服务，可是偏偏又调用不了。</p><p>邮件团队的人说，“看你愁的，我给你提供了一个类似邮局信箱的东西，你往这信箱里写上你要发送的消息，以及我们约定的地址。之后你就不用再操心了，我们自然能从约定的地址中取得消息，进行邮件的相应操作。”</p><p>后来，小明才知道，这就是外界广为流传的消息队列。你不用知道具体的服务在哪，如何调用。你要做的只是将该发送的消息，向你们约定好的地址进行发送，你的任务就完成了。对应的服务自然能监听到你发送的消息，进行后续的操作。这就是消息队列最大的特点，将同步操作转为异步处理，将多服务共同操作转为职责单一的单服务操作，做到了服务间的解耦。</p><p>哈哈，这下能高枕无忧了。太年轻，哪有万无一失的技术啊~</p><p>不久的一天，你会发现所有业务都替换了邮件发送的方式，统一使用了消息队列来进行发送。这下仅仅一个邮件服务模块，难以承受业务方源源不断的消息，大量的消息堆积在了队列中。这就需要更多的消费者（邮件服务）来共同处理队列中的消息，即所谓的分布式消息处理。</p><p>未完待续。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>有了上面的基础，再看非常官方的解释应该也能理解了。</p><p>消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。 ——维基百科</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>解释还是太官方了，我们来看一个最简单的架构模型：</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E5%91%8A%E8%AF%89%E4%BD%A0%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5D-2019-10-12-23-40-18-mq_01.png" alt="[一个故事告诉你什么是消息队列]-2019-10-12-23-40-18-mq_01.png"><ul><li>Producer：消息生产者，负责产生和发送消息到 Broker；</li><li>Broker：消息处理中心。负责消息存储、确认、重试等，一般其中会包含多个 queue；</li><li>Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理；</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h4><p>将耗时的同步操作，通过以发送消息的方式，进行了异步化处理。减少了同步等待的时间。</p><h4 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h4><p>消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节，只要定义好消息的格式就行。</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>通过对消费者的横向扩展，降低了消息队列阻塞的风险，以及单个消费者产生单点故障的可能性（当然消息队列本身也可以做成分布式集群）。</p><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>消息队列一般会把接收到的消息存储到本地硬盘上（当消息被处理完之后，存储信息根据不同的消息队列实现，有可能将其删除），这样即使应用挂掉或者消息队列本身挂掉，消息也能够重新加载。</p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 GitHub Pages 和 Hugo 搭建博客</title>
    <url>/posts/3355505068/</url>
    <content><![CDATA[<p>之前一直在用 wordpress 写博客，服务器放在国外。但是，最近服务器到期，一来是不想再用 wp 了（审美疲劳），二来就是不想再续费了，思来想去，最终决定换个地方写博客。</p><p>感谢 GitHub 给了我们免费的主页空间（GitHub Pages），还有 Hugo 这种好用、好看又强大的静态站点生成框架，最后再结合 Markdown 写文章，真香 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61a.png?v8">😚</span>。</p><a id="more"></a><p>本文主要是记录了搭建过程，和一些使用心得，步骤尽量简短明了。不过，为了确保萌新也可以学会，有些非本文关注的地方，链接到了其他教程（偷懒 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>）。</p><p>话不多说，进入正题。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>如果你没有 GitHub 账号，那么需要先注册一个。<a href="https://www.dogedoge.com/results?q=github+注册" target="_blank" rel="noopener">注册教程戳这里</a>，选一篇适合你的，去注册吧。</p></li><li><p><a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="noopener">Git</a> 是必须的。</p></li><li><p>再有个 <a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">Visaul Studio Code</a> 那就更好了。</p></li></ol><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>我们需要在 GitHub 上创建三个仓库，分别是：</p><ol><li><p>hugo-blog 仓库，这个是用来存放 hugo 框架与主题，最重要的是，我们写的博客文章的md文件一般是放在这里的。</p></li><li><p>GitHub Pages 仓库，用来存放生成好的静态博客站点，按照<a href="https://pages.github.com/" target="_blank" rel="noopener">官网教程</a>来就好。这里需要注意的是，仓库名字的前缀必须要和你的账号相同，这样才会生成 <code>xxxx.github.io</code> 的域名。</p></li><li><p>figurebed 仓库，就是图床啦，用来存放文章图片的，专门用个仓库比较好管理。</p></li></ol><p>假设以下就是上述的三个仓库：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">UserName/hugo-blog.git</span><br><span class="line">UserName/UserName.github.io.git</span><br><span class="line">UserName/figurebed.git</span><br></pre></td></tr></tbody></table></figure><h2 id="安装-Hugo"><a href="#安装-Hugo" class="headerlink" title="安装 Hugo"></a>安装 Hugo</h2><p>Mac 直接使用 Homebrew 安装：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">brew install hugo</span><br></pre></td></tr></tbody></table></figure><p>Windows 需要<a href="https://github.com/gohugoio/hugo/releases" target="_blank" rel="noopener">下载安装包</a>。</p><p>安装完成后，在终端输入以下命令，验证一下：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hugo version</span><br></pre></td></tr></tbody></table></figure><p>如下图所示，说明安装成功</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-13-25-41-BC90513A-87BF-4F0D-AFBD-45F7CB697E20.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-13-25-41-BC90513A-87BF-4F0D-AFBD-45F7CB697E20.png"><h2 id="创建-Hugo-项目"><a href="#创建-Hugo-项目" class="headerlink" title="创建 Hugo 项目"></a>创建 Hugo 项目</h2><p>命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hugo new site my-blog</span><br></pre></td></tr></tbody></table></figure><p><code>my-blog</code> 是 Hugo 项目的目录名称，可以替换为你喜欢的名称。</p><p>创建完成后，在 <code>my-blog</code> 目录下会生成以下文件结构（只列出我们关心的）：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">├── archetypes <span class="comment"># 用户自定义的文章模板</span></span><br><span class="line">├── content <span class="comment"># markdown 文件</span></span><br><span class="line">├── static <span class="comment"># 存放静态文件，比如图片</span></span><br><span class="line">└── themes <span class="comment"># 主题</span></span><br></pre></td></tr></tbody></table></figure><p>用 vs code 打开 <code>my-blog</code> 目录，然后就可以在 vs code 的终端中执行命令了。</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>Hugo 的主题还是比较多的，它们不仅风格迥异，功能也有所不同。但是，很多主题功能都比较简单了，这显然不在我考虑的范围内，所以我选择了 <a href="https://github.com/olOwOlo/hugo-theme-even" target="_blank" rel="noopener">even</a> 这个功能强大、干净又好看的主题。</p><p>当然，你也可以在 <a href="https://themes.gohugo.io/" target="_blank" rel="noopener">Hugo 主题市场</a> 里自己挑选。</p><p>把主题克隆到 <code>themes</code> 目录里就算是安装了：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/olOwOlo/hugo-theme-even themes/even</span><br></pre></td></tr></tbody></table></figure><p>然后把 <code>themes/even/exampleSite</code> 目录下的所有文件（配置文件与示例文档）全都复制到 <code>my-blog</code> 目录下。</p><p>这样就算安装完成了。</p><h2 id="生成与运行"><a href="#生成与运行" class="headerlink" title="生成与运行"></a>生成与运行</h2><p>如前文所说，Hugo 本身并不是一个博客系统，而是一个静态站点的生成框架，配合不同的主题，可以生成出不同的静态站点。</p><p>命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hugo -t even <span class="comment"># 生成站点()，even 是主题名字</span></span><br><span class="line">hugo server <span class="comment"># 生成好了以后，就可以运行了</span></span><br></pre></td></tr></tbody></table></figure><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-14-16-28-WX20191013-141617.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-14-16-28-WX20191013-141617.png"><p>图中红框中就是本地访问地址，可以打开先看看效果。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p><code>my-blog/config.toml</code> 文件就是主题的配置文件，配置项比较丰富，不过好在基本都有中文注释，根据需要自行修改就行了。</p><p>另外，<code>my-blog/static</code> 目录下，可以放一些静态文件，每次 hugo 生成站点时，都会把这个目录里的文件复制到生成的站点中。</p><p>比如，你可以把打赏二维码的图片丢进去</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-14-54-31-20191013145431.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-14-54-31-20191013145431.png"><p>然后修改一下配置里的路径</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-14-43-9-20191013144309.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-14-43-9-20191013144309.png"></p><h2 id="写新文章"><a href="#写新文章" class="headerlink" title="写新文章"></a>写新文章</h2><p>使用命令：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hugo new post/文章名称.md</span><br></pre></td></tr></tbody></table></figure><p>hugo 会使用位于 <code>my-blog/archetypes/default.md</code> 的用户模板文件，在 <code>my-blog/content/post</code>中创建新的文章。</p><p>主题中自带的模板配置项会比较多，可以参考<code>themes/even/archetypes/default.md</code>，自行在文章中或者和用户模板中添加需要的配置项。</p><p>不管是写了新文章，还是修改、删除了原来的文章，都要删除掉以前的 public 目录，然后重新生成站点。</p><blockquote><p>不要忘记把之前的示例文章删掉</p></blockquote><h2 id="部署上线"><a href="#部署上线" class="headerlink" title="部署上线"></a>部署上线</h2><p>还记得之前我们创建的三个 github 仓库吗？</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">UserName/hugo-blog.git <span class="comment"># my-blog 在这里</span></span><br><span class="line">UserName/UserName.github.io.git <span class="comment"># public 放这里</span></span><br><span class="line">UserName/figurebed.git <span class="comment"># 后面再说这个图床怎么用</span></span><br></pre></td></tr></tbody></table></figure><p>接下来，我们就要把博客上传到仓库中，<code>my-blog</code> 目录下执行以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 删掉 public 文件夹，因为每次发布前，都要重新生成它。</span></span><br><span class="line">rm -rf public</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 git</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关联 github 仓库 UserName/hugo-blog.git</span></span><br><span class="line">git remote add origin https://github.com/UserName/hugo-blog.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 public 子模块，生成的站点需要放在 UserName/UserName.github.io.git 仓库里</span></span><br><span class="line">git submodule add https://github.com/UserName/UserName.github.io.git public</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送过去，如果是第一次用 git，这里会让你输入账号和密码</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 public 站点</span></span><br><span class="line">hugo -t even</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 public 目录</span></span><br><span class="line"><span class="built_in">cd</span> public</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交，刚才提交的是 my-blog 库，现在提交的是 public</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个也推送过去</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></tbody></table></figure><p>打完收工 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8">😃</span></p><p>现在可以打开 <code>UserName.github.io</code> 去看看你的博客了。</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>如果每一次写文章都要这么发布一次，确实也挺累了，所以我们写个 shell。</p><p>创建一个 <code>deploy.sh</code> 文件，把以下命令复制进去。这样以后编辑文章，在终端中执行一下就行了。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"\033[0;32mDeploying blog updates to GitHub...\033[0m\n"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除旧发布目录</span></span><br><span class="line">rm -rf ./public</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 public.</span></span><br><span class="line">hugo -t even</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成提交信息.</span></span><br><span class="line">msg=<span class="string">"rebuilding site <span class="variable">$(date)</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"$*"</span> ]; <span class="keyword">then</span></span><br><span class="line">    msg=<span class="string">"$*"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交&推送 hugo-blog</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"<span class="variable">$msg</span>"</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"\n\033[0;32mDeploying public updates to GitHub...\033[0m\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> public</span><br><span class="line"><span class="comment"># 还原 public git 子模块</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"gitdir: ../.git/modules/public"</span> > <span class="string">".git"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交&推送 public</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"<span class="variable">$msg</span>"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></tbody></table></figure><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>因为我们使用 markdown 写博客，所以文章配图需要先上传某个服务器，然后再把地址贴上来，这样显然会比较麻烦。</p><p>当然，在 <code>vs code</code> 里没有什么麻烦是插件解决不了的。</p><p>在 <code>vs code</code> 中安装 <a href="https://marketplace.visualstudio.com/items?itemName=Spades.vs-picgo" target="_blank" rel="noopener">picgo</a> 这个插件。</p><p>然后进入该插件配置项</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-15-39-9-20191013153909.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-15-39-9-20191013153909.png" width="300"><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A" target="_blank" rel="noopener">GitHub Token 获取方式</a></p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-15-41-20-20191013154119.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-15-41-20-20191013154119.png" width="400"><p>配置完以后，就可以使用它来帮我们上传图片（文件、截图等）了，它会帮我们把图片地址自动回填到编辑器的光标处。</p><h3 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h3><table><thead><tr><th>系统</th><th>剪切板(截图)</th><th>资源管理器(文件)</th></tr></thead><tbody><tr><td>Win</td><td>Ctrl + Alt + U</td><td>Ctrl + Alt + E</td></tr><tr><td>Mac</td><td>Cmd + Opt + U</td><td>Cmd + Opt + E</td></tr></tbody></table><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
