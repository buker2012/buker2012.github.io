<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>彻底搞懂 JS 中正则表达式</title>
    <url>/posts/308772757/</url>
    <content><![CDATA[<h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part.1"></a>Part.1</h2><p>正则表达式能在字符串中查找匹配特定模式的子字符串。</p><p>在JavaScript中，可以通过斜线 // 来创建，也可以通过<code>new RegExp()</code>来创建，然后就能使用<code>match</code>、<code>test</code>、<code>replace</code>等方法。</p><a id="more"></a><p>你可以事先定义正则表达式，也可以在调用方法时随时定义。</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-3-23-20191011190323.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-3-23-20191011190323.png"><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part.2"></a>Part.2</h2><p>每次匹配一个字符，将多个字符放到方括号 [] 中可以匹配多个匹配的字符。</p><p>用横线 - 匹配字符范围。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-6-8-20191011190607.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-6-8-20191011190607.png"></p><h2 id="Part-3"><a href="#Part-3" class="headerlink" title="Part.3"></a>Part.3</h2><p>在正则表达式末尾添加额外的标记来修改匹配器的行为。</p><p>JavaScript 支持如下标记：</p><ul><li>i = 不区分大小写</li><li>m = 多行匹配</li><li>g = 全局匹配（查找所有匹配，而不是仅查找一个）</li></ul><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-6-24-20191011190623.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-6-24-20191011190623.png"></p><h2 id="Part-4"><a href="#Part-4" class="headerlink" title="Part.4"></a>Part.4</h2><p>在模式开头使用箭头 <code>^</code> 表示“字符串开头”。</p><p>在模式末尾使用美元符号 <code>$</code> 表示“字符串结尾”。</p><p>将多个模式放在一起以匹配更长的字符串。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-6-36-20191011190635.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-6-36-20191011190635.png"></p><h2 id="Part-5"><a href="#Part-5" class="headerlink" title="Part.5"></a>Part.5</h2><p>使用通配符和特殊的转义字符来匹配字符类。</p><p>. = 除了换行之外的任何字符。</p><ul><li>\d = 数字</li><li>\D = 非数字</li><li>\s = 空白</li><li>\S = 非空白</li><li>\n = 新行</li></ul><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-6-49-20191011190648.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-6-49-20191011190648.png"></p><h2 id="Part-6"><a href="#Part-6" class="headerlink" title="Part.6"></a>Part.6</h2><p>用数量修饰符来匹配特定数量的字符。</p><ul><li>*= 零个或多个</li><li>+= 一个或多个</li><li>？= 零个或一个</li><li>{3} = 正好3个</li><li>{2,4} = 2, 3, 或4个</li><li>{2,} = 2或多个</li></ul><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-6-59-20191011190658.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-6-59-20191011190658.png"></p><h2 id="Part-7"><a href="#Part-7" class="headerlink" title="Part.7"></a>Part.7</h2><p>使用括号 () 来分组。</p><p><code>match</code>会返回完整的匹配，外加每个分组，除非你使用了g标记。</p><p>在括号 () 内使用管道符号 | 来表示分组的匹配内容。</p><ul><li>| = 或者</li></ul><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-7-9-20191011190709.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-7-9-20191011190709.png"></p><h2 id="Part-8"><a href="#Part-8" class="headerlink" title="Part.8"></a>Part.8</h2><p>要匹配特殊字符，需要用反斜杠 <code>\</code> 将其转义。</p><p>JS正则表达式中的特殊字符包括：<code>^ $ \ . * + ? ( ) [ ] { } |</code></p><p>所以，要想匹配星号，需要使用：</p><ul><li><code>\*</code></li><li>而不能仅使用 <code>*</code></li></ul><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-7-23-20191011190722.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-7-23-20191011190722.png"></p><h2 id="Part-9"><a href="#Part-9" class="headerlink" title="Part.9"></a>Part.9</h2><p>要想匹配除了特定字符之外的任意字符，可以在方括号内使用^。</p><p>这意味着 ^ 有两种含义，可能会造成混淆。</p><p>当它出现在正则表达式开头时，它表示“字符串开头”；出现在方括号内时，表示“不是这些字符串”。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/
%5B%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20JS%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D-2019-10-11-19-7-33-20191011190733.png" alt="[彻底搞懂 JS 中的正则表达式]-2019-10-11-19-7-33-20191011190733.png"></p><h2 id="Part-10"><a href="#Part-10" class="headerlink" title="Part.10"></a>Part.10</h2><p>正则表示可以用来查找并匹配各种东西，比如URL和文件名。</p><p>但是！对于非常复杂的任务，使用正则表达式时一定要小心，比如分析电子邮件（你很容易就会弄得一团糟），或者分析HTML（HTML不是正规的语言，所以没办法完全使用正则表达式来解析）。</p><p>当然，正则表达式还有更多内容，如懒惰 vs 贪婪，前向，捕获等。</p><p>但是，对于绝大多数Web开发者来说，掌握这些最基本的组成部分就够了。</p><hr><blockquote><p>原文：<a href="https://dev.to/chrisachard/intro-to-regex-for-web-developers-2fj4" target="_blank" rel="noopener">https://dev.to/chrisachard/intro-to-regex-for-web-developers-2fj4</a><br>作者：Chris Achard，程序员，日常使用JS, React, Rails和Node，在egghead.io上讲课。<br>本文为 CSDN 翻译，转载请注明来源出处。</p></blockquote><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(7):实体模型</title>
    <url>/posts/2656483526/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
        <tag>FreeSql</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(6):Swagger</title>
    <url>/posts/2656483526/</url>
    <content><![CDATA[<p><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 也称为 <a href="https://www.openapis.org/" target="_blank" rel="noopener">OpenAPI</a>，它解决了为 Web API 生成有用文档和帮助页的问题。 它具有诸如交互式文档、客户端 SDK 生成和 API 可发现性等优点。</p><p>说白了，它可以为我们的 WebAPI 提供了文档说明页面，并且可以进行简单的 API 调用测试。</p><a id="more"></a><h2 id="添加-Swagger"><a href="#添加-Swagger" class="headerlink" title="添加 Swagger"></a>添加 Swagger</h2><ol><li><p>运行以下命令，添加 Swashbuckle.AspNetCore 包</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到项目目录</span></span><br><span class="line"><span class="built_in">cd</span> zilor.Order.WebApi</span><br><span class="line"><span class="comment"># 添加 Swashbuckle.AspNetCore 包</span></span><br><span class="line">dotnet add package Swashbuckle.AspNetCore --version 5.0.0-rc4</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改项目文件，启用 xml 注释文档，提供给 swagger 使用</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-5-%E5%88%9B%E5%BB%BA%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%5D-2019-10-27-10-52-46.png" alt></p></li><li><p>在 Startup 类中，导入以下命名空间：</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.OpenApi.Models;</span><br></pre></td></tr></tbody></table></figure></li><li><p>将 Swagger 生成器添加到 Startup.ConfigureServices 方法中的服务集合中</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    services.AddControllers();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 Swagger 生成器添加到 Startup.ConfigureServices 方法中的服务集合中</span></span><br><span class="line">    services.AddSwaggerGen(c =></span><br><span class="line">    {</span><br><span class="line">        c.SwaggerDoc(<span class="string">"v1"</span>, <span class="keyword">new</span> OpenApiInfo</span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">            Title = <span class="string">"订单采集小程序 API"</span>,</span><br><span class="line">            Version = <span class="string">"v1"</span></span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> xmlFile = <span class="string">$"<span class="subst">{Assembly.GetExecutingAssembly().GetName().Name}</span>.xml"</span>;</span><br><span class="line">        <span class="keyword">var</span> xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);</span><br><span class="line">        c.IncludeXmlComments(xmlPath);</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>在 Startup.Configure 方法中，启用中间件为生成的 JSON 文档和 Swagger UI 提供服务</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  app.UseSwagger();</span><br><span class="line">  app.UseSwaggerUI(c =></span><br><span class="line">  {</span><br><span class="line">      c.SwaggerEndpoint(<span class="string">"/swagger/v1/swagger.json"</span>, <span class="string">"订单采集小程序 API V1"</span>);</span><br><span class="line">  });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="使用-swagger"><a href="#使用-swagger" class="headerlink" title="使用 swagger"></a>使用 swagger</h2><ol start="6"><li><p>在控制器上添加 xml 注释</p><p>安装 vs code 插件 <code>C# XML Documentation Comments</code>，可以通过输入<code>///</code>快速添加 xml 注释。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-6-Swagger%5D-2019-10-27-11-24-12.png" alt></p></li></ol><ol start="7"><li><p>按下键盘上的 F5，调试运行项目，导航到 <code>https://localhost:5001/swagger</code> 地址，可以看到当前项目所有 API 接口的说明。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-5-%E5%88%9B%E5%BB%BA%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%5D-2019-10-27-11-5-59.png" alt></p></li><li><p>点击接口可以展开，查看更详细的信息，还可以直接调用接口，进行测试。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-6-Swagger%5D-2019-10-27-11-33-46.png" alt></p></li></ol><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(5):解决方案</title>
    <url>/posts/3008954784/</url>
    <content><![CDATA[<p>我们这个案例分为前端小程序和后端 Web API 两个项目。虽然先做哪个都可以，但是惯例上来说，一般是先后再前。</p><h2 id="dotnet"><a href="#dotnet" class="headerlink" title="dotnet"></a>dotnet</h2><p>使用 vs code 作为开发工具，必须使用 dotnet 命令，在命令行环境下才能创建 ASP.NEW Web API 项目。</p><a id="more"></a><p>首先安装 <a href="https://dotnet.microsoft.com/download" target="_blank" rel="noopener">.NET Core 3.0 SDK</a> ，如果你已经安装了最新的 vs 2019，那么就不需要这一步了。安装过程过于简单，不再描述。</p><p>打开命令行工具，输入以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">dotnet --info</span><br></pre></td></tr></tbody></table></figure><p>看看是否成功，版本是否正确：</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/20191025152310.png" alt></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>创建文件夹<code>Zilor.Order</code></p></li><li><p>在 vs code 中打开它</p></li><li><p>打开终端（<code>Ctrl + ~</code>），运行以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 创建解决方案</span></span><br><span class="line">dotnet new sln</span><br><span class="line"><span class="comment"># 创建 ASP.NET Core WebApi 项目</span></span><br><span class="line">dotnet new webapi -n zilor.Order.WebApi</span><br><span class="line"><span class="comment"># 添加 WebApi 项目到解决方案中</span></span><br><span class="line">dotnet sln Zilor.Order.sln add zilor.Order.WebApi/zilor.Order.WebApi.csproj</span><br></pre></td></tr></tbody></table></figure></li></ol><p>新创建的 WebApi 项目，默认添加了一个 <code>WeatherForecast</code> 控制器，相当于 Hello World。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BNET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-5-%E5%88%9B%E5%BB%BA%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%5D-2019-10-27-11-9-37.png" alt></p><p>如果你是第一次用 vs code 打开 .Net Core 工程目录，那么随便打开一个 .cs 文件，右下角会弹出类似下图的询问框。它在问你要不要安装支持 C# 的插件和 Debug 配置文件，一律 Yes 即可。</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/20191025153605.png" alt></p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(4):接口设计</title>
    <url>/posts/771724912/</url>
    <content><![CDATA[<p>Web API 接口是前端和后端通讯的主要方式，所以在做前后端分离的项目时，需要先设计好 API 接口。</p><p>尤其是当前端和后端的开发人员不是同一个人时，那么在编码前，就必须约定好接口规范。否则，你做你的，我做我的，最后发现对接不上，那就很糟糕了。</p><a id="more"></a><p>即便这篇教程里的案例很简单，我也仍然建议大家先把接口设计好，这样就不会在编码时找不到方向，随性而为，甚至写着写着，接口就偏离了 RESTFul 风格。</p><h2 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h2><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p><strong>简要描述</strong></p><ul><li>使用钉钉免登授权码换取jwt token，其它接口需要 token 进行鉴权</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/session</li></ul><p><strong>请求方式</strong></p><ul><li>POST</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>code</td><td>是</td><td>string</td><td>钉钉免登授权码</td></tr></tbody></table><p><strong>返回正确示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"token"</span>: <span class="string">"abcd*****efg"</span> <span class="comment">// JWT Token</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="商品资料相关"><a href="#商品资料相关" class="headerlink" title="商品资料相关"></a>商品资料相关</h2><h3 id="商品资料查询"><a href="#商品资料查询" class="headerlink" title="商品资料查询"></a>商品资料查询</h3><p><strong>简要描述</strong></p><ul><li>按商品条码查询商品资料，需要鉴权</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/good</li></ul><p><strong>请求方式</strong></p><ul><li>GET</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>barcode</td><td>是</td><td>string</td><td>商品条码</td></tr></tbody></table><p><strong>返回正确示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"barcode"</span>: <span class="number">1000000001</span>, <span class="comment">// 商品条码</span></span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"可口可乐"</span>, <span class="comment">// 商品名称</span></span><br><span class="line">  <span class="string">"sort1"</span>: <span class="string">"饮料"</span>, <span class="comment">// 商品类别1</span></span><br><span class="line">  <span class="string">"sort2"</span>: <span class="string">"碳酸饮料"</span>, <span class="comment">// 商品类别2</span></span><br><span class="line">  <span class="string">"spec"</span>: <span class="string">"24*200ml"</span> <span class="comment">// 商品规格</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="订单相关"><a href="#订单相关" class="headerlink" title="订单相关"></a>订单相关</h2><h3 id="历史订单查询"><a href="#历史订单查询" class="headerlink" title="历史订单查询"></a>历史订单查询</h3><p><strong>简要描述</strong></p><ul><li>查询用户历史订单，需要鉴权，默认查询前20条</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/orders</li></ul><p><strong>请求方式</strong></p><ul><li>GET</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>pageIndex</td><td>否</td><td>int</td><td>页码，默认查询第 1 页</td></tr><tr><td>pageSize</td><td>否</td><td>int</td><td>页尺寸，默认查询 20 条</td></tr><tr><td>state</td><td>否</td><td>int</td><td>订单状态，0、未确认，1、已确认，默认查询全部</td></tr></tbody></table><p><strong>返回正确示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">1000000001</span>, <span class="comment">// 订单编号</span></span><br><span class="line">    <span class="string">"date"</span>: <span class="string">"2019-09-30"</span>, <span class="comment">// 订单日期</span></span><br><span class="line">    <span class="string">"count"</span>: <span class="number">100</span>, <span class="comment">// 订单商品数量</span></span><br><span class="line">    <span class="string">"state"</span>: <span class="number">0</span> <span class="comment">// 状态，0、未确认，1、已确认</span></span><br><span class="line">  },</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h3 id="订单查询"><a href="#订单查询" class="headerlink" title="订单查询"></a>订单查询</h3><p><strong>简要描述</strong></p><ul><li>按订单编号查询订单，需要鉴权</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/orders</li></ul><p><strong>请求方式</strong></p><ul><li>GET</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>int</td><td>订单编号</td></tr></tbody></table><p><strong>返回正确示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">1000000001</span>, <span class="comment">// 订单编号</span></span><br><span class="line">    <span class="string">"date"</span>: <span class="string">"2019-09-30"</span>, <span class="comment">// 订单日期</span></span><br><span class="line">    <span class="string">"count"</span>: <span class="number">100</span>, <span class="comment">// 订单商品数量</span></span><br><span class="line">    <span class="string">"state"</span>: <span class="number">0</span> <span class="comment">// 状态，0、未确认，1、已确认</span></span><br><span class="line">  },</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h3 id="订单添加"><a href="#订单添加" class="headerlink" title="订单添加"></a>订单添加</h3><p><strong>简要描述</strong></p><ul><li>添加新的订单，并返回订单号</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/orders</li></ul><p><strong>请求方式</strong></p><ul><li>POST</li></ul><p><strong>请求参数</strong></p><ul><li>无</li></ul><p><strong>返回正确示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"id"</span>: <span class="number">100000001</span>, <span class="comment">// 订单编号</span></span><br><span class="line">  <span class="string">"date"</span>: <span class="string">"2019-09-30"</span> <span class="comment">// 订单日期</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="订单修改"><a href="#订单修改" class="headerlink" title="订单修改"></a>订单修改</h3><p><strong>简要描述</strong></p><ul><li>修改指定编号订单内容，需要鉴权，只能修改状态为「未确认」订单的「日期」字段</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/orders</li></ul><p><strong>请求方式</strong></p><ul><li>PUT</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>int</td><td>要修改的订单编号</td></tr><tr><td>date</td><td>否</td><td>string</td><td>订单日期，格式：“yyyy-MM-dd”，例：“2019-09-30”</td></tr></tbody></table><p><strong>返回正确示例</strong></p><p>无</p><h3 id="订单删除"><a href="#订单删除" class="headerlink" title="订单删除"></a>订单删除</h3><p><strong>简要描述</strong></p><ul><li>删除指定编号订单，包括订单明细，需要鉴权</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/orders</li></ul><p><strong>请求方式</strong></p><ul><li>DELETE</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>int</td><td>订单编号</td></tr></tbody></table><p><strong>返回正确示例</strong></p><ul><li>无</li></ul><h2 id="订单明细相关"><a href="#订单明细相关" class="headerlink" title="订单明细相关"></a>订单明细相关</h2><h3 id="订单明细查询"><a href="#订单明细查询" class="headerlink" title="订单明细查询"></a>订单明细查询</h3><p><strong>简要描述</strong></p><ul><li>按订单编号查询订单的商品明细，需要鉴权</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order-details</li></ul><p><strong>请求方式</strong></p><ul><li>GET</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>int</td><td>订单编号</td></tr></tbody></table><p><strong>返回正确示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"barcode"</span>: <span class="string">"123456789"</span>, <span class="comment">// 商品条码</span></span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"可口可乐"</span>, <span class="comment">// 商品名称</span></span><br><span class="line">    <span class="string">"sort1"</span>: <span class="string">"饮料"</span>, <span class="comment">// 商品类别1</span></span><br><span class="line">    <span class="string">"sort2"</span>: <span class="string">"碳酸饮料"</span>, <span class="comment">// 商品类别2</span></span><br><span class="line">    <span class="string">"spec"</span>: <span class="string">"24*100ml"</span>, <span class="comment">// 规格</span></span><br><span class="line">    <span class="string">"count"</span>: <span class="number">100</span> <span class="comment">// 商品数量</span></span><br><span class="line">  },</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h3 id="订单明细添加"><a href="#订单明细添加" class="headerlink" title="订单明细添加"></a>订单明细添加</h3><p><strong>简要描述</strong></p><ul><li>添加订单商品明细，需要鉴权</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order-details</li></ul><p><strong>请求方式</strong></p><ul><li>POST</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>barcode</td><td>是</td><td>string</td><td>商品条码</td></tr><tr><td>count</td><td>是</td><td>int</td><td>商品数量</td></tr></tbody></table><p><strong>返回正确示例</strong></p><ul><li>无</li></ul><h3 id="订单明细修改"><a href="#订单明细修改" class="headerlink" title="订单明细修改"></a>订单明细修改</h3><p><strong>简要描述</strong></p><ul><li>修改订单的商品明细，需要鉴权</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order-details</li></ul><p><strong>请求方式</strong></p><ul><li>PUT</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>int</td><td>订单商品明细 id</td></tr><tr><td>barcode</td><td>是</td><td>string</td><td>商品条码</td></tr><tr><td>count</td><td>是</td><td>int</td><td>商品数量</td></tr></tbody></table><p><strong>返回正确示例</strong></p><ul><li>无</li></ul><h3 id="订单明细删除"><a href="#订单明细删除" class="headerlink" title="订单明细删除"></a>订单明细删除</h3><p><strong>简要描述</strong></p><ul><li>删除订单的商品明细，需要鉴权</li></ul><p><strong>请求 URL</strong></p><ul><li>/api/order-details</li></ul><p><strong>请求方式</strong></p><ul><li>DELETE</li></ul><p><strong>请求参数</strong></p><table><thead><tr><th>参数名</th><th>必须</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>是</td><td>int</td><td>订单商品明细 id</td></tr></tbody></table><p><strong>返回正确示例</strong></p><ul><li>无</li></ul><h2 id="全局错误状态码"><a href="#全局错误状态码" class="headerlink" title="全局错误状态码"></a>全局错误状态码</h2><table><thead><tr><th>HTTP 状态码</th><th>名称</th><th>错误解释</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>一般性异常错误</td></tr><tr><td>401</td><td>Unauthorized</td><td>未授权，Token 认证错误</td></tr><tr><td>404</td><td>Not Found</td><td>请求的资源未找到</td></tr><tr><td>409</td><td>Conflict</td><td>资源发生冲突</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误</td></tr></tbody></table><p>具体错误消息放在消息体的 msg 中，示例：</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"msg"</span>: <span class="string">"这是具体的错误原因"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>ABP入门教程(4):初始化运行</title>
    <url>/posts/3644403578/</url>
    <content><![CDATA[<p>重新生成解决方案，确保生成成功。</p><a id="more"></a><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>打开JD.CRS.Web.Host / appsettings.json，修改数据库连接设置ConnectionStrings．</p><p>打开JD.CRS.Web.Host / appsettings.json，做同样修改．</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BABP%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%90%E8%A1%8C%5D-2019-10-25-13-13-42-25612-20191001145026900-205043747.png" alt="[ABP入门教程-4-初始化运行]-2019-10-25-13-13-42-25612-20191001145026900-205043747.png"><h2 id="迁移数据库"><a href="#迁移数据库" class="headerlink" title="迁移数据库"></a>迁移数据库</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>设置JD.CRS.Web.Mvc为启始项目</p><p>打开工具 / NuGet包管理器 / 程序包管理器控制台</p><p>默认项目选择JD.CRS.EntityFrameworkCore</p><p>依次执行以下命令即可</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Add-Migration <span class="string">'Initial'</span></span><br><span class="line">Update-Database</span><br></pre></td></tr></tbody></table></figure><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BABP%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%90%E8%A1%8C%5D-2019-10-25-13-14-3-25612-20191001151744140-1232125703.png" alt="[ABP入门教程-4-初始化运行]-2019-10-25-13-14-3-25612-20191001151744140-1232125703.png"><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>设置JD.CRS.Migrator为启始项目</p><p>F5运行</p><p>控制台询问时输入Y，回车即可</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BABP%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%90%E8%A1%8C%5D-2019-10-25-13-14-40-!%5B%5D(httpsimg2018.cnblogs.comblog2561220191025612-20191001152236037-1939033831.png)" alt="[ABP入门教程-4-初始化运行]-2019-10-25-13-14-40-![](httpsimg2018.cnblogs.comblog2561220191025612-20191001152236037-1939033831.png)"><h2 id="运行应用程序"><a href="#运行应用程序" class="headerlink" title="运行应用程序"></a>运行应用程序</h2><h3 id="Web-Host"><a href="#Web-Host" class="headerlink" title="Web.Host"></a>Web.Host</h3><p>设置JD.CRS.Web.Host为启始项目</p><p>F5运行</p><p>显示Swagger界面即WebAPI运行成功</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BABP%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%90%E8%A1%8C%5D-2019-10-25-13-16-6.png)%0A" alt="[ABP入门教程-4-初始化运行]-2019-10-25-13-16-6.png)
"></p><h3 id="Web-MVC"><a href="#Web-MVC" class="headerlink" title="Web.MVC"></a>Web.MVC</h3><p>设置JD.CRS.Web.Mvc为启始项目</p><p>F5运行</p><p>登录账号admin / 123qwe</p><p>显示此界面即WebMVC运行成功</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BABP%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%90%E8%A1%8C%5D-2019-10-25-13-16-34.png)" alt="[ABP入门教程-4-初始化运行]-2019-10-25-13-16-34.png)"><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>ABP</tag>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>ABP入门教程(3):解决方案</title>
    <url>/posts/3002779011/</url>
    <content><![CDATA[<p><a href="https://aspnetboilerplate.com/Templates" target="_blank" rel="noopener">点这里进入ABP启动模板</a></p><p>如图操作，我们先生成一个基于 .NET Core 的MPA(多页面应用)．点击”Create my project!”即可创建项目．</p><a id="more"></a> <img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BABP%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%5D-2019-10-25-13-11-44-20191025131144.png" alt="[ABP入门教程-3-解决方案]-2019-10-25-13-11-44-20191025131144.png"><h2 id="解读项目"><a href="#解读项目" class="headerlink" title="解读项目"></a>解读项目</h2><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BABP%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%5D-2019-10-25-13-12-54-25612-20190930185913158-22173165.png" alt="[ABP入门教程-3-解决方案]-2019-10-25-13-12-54-25612-20190930185913158-22173165.png"><h3 id="展示层-JD-CRS-Web-Mvc"><a href="#展示层-JD-CRS-Web-Mvc" class="headerlink" title="展示层 (JD.CRS.Web.Mvc)"></a>展示层 (JD.CRS.Web.Mvc)</h3><p>提供一个用户界面，实现用户交互操作。</p><p>ASP.NET Core MVC（模型-视图-控制器）可以视为展示层。它可以是物理层（通过HTTP API使用应用程序）或逻辑层（直接注入和使用应用程序服务）。无论哪种情况，它都可以包括 本地化，导航，对象映射， 缓存，配置管理，审计日志等。它还处理 授权，会话， 功能（用于 多租户应用程序）和异常处理。</p><h3 id="分布式服务层（JD-CRS-Web-Host）"><a href="#分布式服务层（JD-CRS-Web-Host）" class="headerlink" title="分布式服务层（JD.CRS.Web.Host）"></a>分布式服务层（JD.CRS.Web.Host）</h3><p>用于公开应用程序接口供远程客户端调用。比如通过ASP.NET Web API和WCF来实现。</p><p>该层用于通过REST，OData，GraphQL等远程API来提供应用程序/域功能…它们不包含业务逻辑，而仅将HTTP请求转换为域交互，或者可以使用应用程序服务来委托操作。该层通常包括授权，缓存， 审核日志记录，对象映射，异常处理，会话等。</p><h3 id="应用层-JD-CRS-Application"><a href="#应用层-JD-CRS-Application" class="headerlink" title="应用层 (JD.CRS.Application)"></a>应用层 (JD.CRS.Application)</h3><p>进行展现层与领域层之间的协调，协调业务对象来执行特定的应用程序的任务。它不包含业务逻辑。</p><p>应用层主要包括应用服务的使用领域层和领域对象（领域服务， 实体 …）来执行请求的应用程序的功能。它使用数据传输对象从表示层或分布式服务层获取数据并将数据返回到表示层或分布式服务层。它还可以处理 授权，缓存，审核日志记录，对象映射，会话等。</p><h3 id="领域层-JD-CRS-Core"><a href="#领域层-JD-CRS-Core" class="headerlink" title="领域层 (JD.CRS.Core)"></a>领域层 (JD.CRS.Core)</h3><p>包括业务对象和业务规则，这是应用程序的核心层。</p><p>这是实现我们的领域逻辑的主要层。它包括 实体，值对象和领域服务以执行业务/领域逻辑。它还可以包括规范和触发领域事件。它定义了存储库接口以从数据源（通常是DBMS）读取和保留实体。</p><h3 id="基础设施层-JD-CRS-EntityFrameworkCore"><a href="#基础设施层-JD-CRS-EntityFrameworkCore" class="headerlink" title="基础设施层 (JD.CRS.EntityFrameworkCore)"></a>基础设施层 (JD.CRS.EntityFrameworkCore)</h3><p>提供通用技术来支持更高的层。例如基础设施层的仓储(Repository)可通过ORM来实现数据库交互。</p><p>基础设施层使其他层起作用：它实现存储库接口（例如，使用Entity Framework Core）以实际使用实际数据库。它还可能包括与供应商的集成，以发送电子邮件等。这不是所有层下的严格层，但实际上通过实现抽象层来支持其他层。</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>JD.CRS.Migrator 提供数据库迁移操作。</p><p>JD.CRS.Web.Core 封装Web层核心功能。</p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>ABP</tag>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>ABP入门教程(2):体系架构</title>
    <url>/posts/3287174117/</url>
    <content><![CDATA[<p>应用程序代码库的分层是一种广泛接受的技术，可帮助降低复杂性并提高代码可重用性。为了实现分层体系结构，ASP.NET Boilerplate遵循域驱动设计的原理。</p><a id="more"></a><h2 id="DDD分层体系架构"><a href="#DDD分层体系架构" class="headerlink" title="DDD分层体系架构"></a>DDD分层体系架构</h2><p>领域驱动设计(DDD:Domain-Driven Design)有四个基本层：</p><ul><li>展示层：为用户提供界面。使用应用程序层来实现用户交互。</li><li>应用层：在表示层和域层之间进行中介。编排业务对象以执行特定的应用程序任务。</li><li>领域层：包括业务对象及其规则。这是应用程序的核心。</li><li>基础设施层：提供通用技术功能，这些功能主要使用第三方库来支持更高的层。</li></ul><h2 id="ABP分层体系架构"><a href="#ABP分层体系架构" class="headerlink" title="ABP分层体系架构"></a>ABP分层体系架构</h2><p>除了DDD外，现代架构应用程序中还包含其他逻辑和物理层。建议并为ABP应用程序实现以下模型。ABP不仅通过提供基类和服务使实现此模型更加容易，而且还提供了直接从该模型开始的启动模板。<br><img src="https://raw.githubusercontent.com/aspnetboilerplate/aspnetboilerplate/master/doc/WebSite/images/abp-nlayer-architecture.png" alt></p><h3 id="客户应用"><a href="#客户应用" class="headerlink" title="客户应用"></a>客户应用</h3><p>这些是远程客户端，它们通过HTTP API（API控制器，OData控制器，甚至是GraphQL端点）将应用程序用作服务。远程客户端可以是SPA（单页面应用程序），移动应用程序或第三方用户。本地化和 导航可以在此应用程序内完成。</p><h3 id="展示层"><a href="#展示层" class="headerlink" title="展示层"></a>展示层</h3><p>ASP.NET Core MVC（模型-视图-控制器）可以视为展示层。它可以是物理层（通过HTTP API使用应用程序）或逻辑层（直接注入和使用应用程序服务）。无论哪种情况，它都可以包括 本地化，导航，对象映射， 缓存，配置管理，审计日志等。它还处理 授权，会话， 功能（用于 多租户应用程序）和异常处理。</p><h3 id="分布式服务层"><a href="#分布式服务层" class="headerlink" title="分布式服务层"></a>分布式服务层</h3><p>该层用于通过REST，OData，GraphQL等远程API来提供应用程序/域功能…它们不包含业务逻辑，而仅将HTTP请求转换为域交互，或者可以使用应用程序服务来委托操作。该层通常包括授权，缓存， 审核日志记录，对象映射，异常处理，会话等。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层主要包括应用服务的使用领域层和领域对象（领域服务， 实体 …）来执行请求的应用程序的功能。它使用数据传输对象从表示层或分布式服务层获取数据并将数据返回到表示层或分布式服务层。它还可以处理 授权，缓存，审核日志记录，对象映射，会话等。</p><h3 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h3><p>这是实现我们的领域逻辑的主要层。它包括 实体，值对象和领域服务以执行业务/领域逻辑。它还可以包括规范和触发领域事件。它定义了存储库接口以从数据源（通常是DBMS）读取和保留实体。</p><h3 id="基础设施层"><a href="#基础设施层" class="headerlink" title="基础设施层"></a>基础设施层</h3><p>基础设施层使其他层起作用：它实现存储库接口（例如，使用Entity Framework Core）以实际使用实际数据库。它还可能包括与供应商的集成，以发送电子邮件等。这不是所有层下的严格层，但实际上通过实现抽象层来支持其他层。</p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>ABP</tag>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>ABP入门教程(1):开篇</title>
    <url>/posts/695756938/</url>
    <content><![CDATA[<p>发现一个很适合新手入门的 ABP 系列教程，内容是讲解如何基于 ABP 实现 CURD (增删改查)示例。</p><p>非常值得转载过来整理整理收藏一下，顺便也复习复习，这东西很久没用了，听说又出了穿新版本。</p><p>哎，真是<code>框架海无涯</code>啊！</p><a id="more"></a><p>以下是正文，<a href="/tags/ABP/">目录在这里</a>。</p><hr><p>ABP是“ASP.NET Boilerplate Project (ASP.NET样板项目)”的简称。</p><p>ASP.NET Boilerplate是一个用最佳实践和流行技术开发现代WEB应用程序的新起点，它旨在成为一个通用的WEB应用程序框架和项目模板。</p><p>ABP的官方网站：<a href="http://www.aspnetboilerplate.com" target="_blank" rel="noopener">http://www.aspnetboilerplate.com</a></p><p>ABP在Github上的开源项目：<a href="https://github.com/aspnetboilerplate" target="_blank" rel="noopener">https://github.com/aspnetboilerplate</a></p><h2 id="ABP-的由来"><a href="#ABP-的由来" class="headerlink" title="ABP 的由来"></a>ABP 的由来</h2><p>“DRY——避免重复代码”是一个优秀的开发者在开发软件时所具备的最重要的思想之一。我们在开发企业WEB应用程序时都有一些类似的需求，例如：都需要登录页面、用户/角色管理、权限验证、数据有效性验证、多语言/本地化等等。一个高品质的大型软件都会运用一些最佳实践，例如分层体系结构、领域驱动设计、依赖注入等。我们也可能会采用ORM、数据库迁移（Database Migrations）、日志记录（Logging）等工具。</p><p>从零开始创建一个企业应用程序是一件繁琐的事，因为需要重复做很多常见的基础工作。许多公司都在开发自己的应用程序框架来重用于不同的项目，然后在框架的基础上开发一些新的功能。但并不是每个公司都有这样的实力。假如我们可以分享的更多，也许可以避免每个公司或每个项目的重复编写类似的代码。作者之所以把项目命名为“ASP.NET Boilerplate”，就是希望它能成为开发一般企业WEB应用的新起点，直接把ABP作为项目模板。</p><h2 id="ABP是什么？"><a href="#ABP是什么？" class="headerlink" title="ABP是什么？"></a>ABP是什么？</h2><p>ABP是为新的现代Web应用程序使用最佳实践和使用最流行工具的一个起点。可作为一般用途的应用程序的基础框架或项目模板。它的功能包括：</p><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>基于最新的.NET技术 （ASP.NET Core，EF Cor，ASP.NET MVC 5.x，EF6.x）<br>实现领域驱动设计（实体、仓储、领域服务、领域事件、应用服务、数据传输对象，工作单元等等）<br>实现分层体系结构（领域层，应用层，展现层和基础设施层）<br>提供了一个基础架构来开发可重用可配置的模块<br>集成一些最流行的开源框架/库，也许有些是你正在使用的<br>提供了一个基础架构让我们很方便地使用依赖注入（使用Castle Windsor作为依赖注入的容器）<br>提供Repository仓储模式支持不同的ORM（已实现Entity Framework 、NHibernate、MangoDb和内存数据库）<br>支持并实现数据库迁移（EF 的 Code first）<br>模块化开发（每个模块有独立的EF DbContext，可单独指定数据库）<br>包括一个简单的和灵活的多语言/本地化系统<br>包括一个 EventBus来实现服务器端全局的领域事件<br>统一的异常处理（应用层几乎不需要处理自己写异常处理代码）<br>数据有效性验证（Asp.NET MVC只能做到Action方法的参数验证，ABP实现了Application层方法的参数有效性验证）<br>通过Application Services自动创建Web API层（不需要写APIController层了）<br>提供基类和帮助类让我们方便地实现一些常见的任务<br>使用“约定优于配置原则”</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>Bootstrap、jQuery、Angular、Vue、React和其他JS库: jQuery.validate、jQuery.form、jQuery.blockUI、json2等<br>为单页面应用程序（Angular，Vue，React）和多页面应用程序（Bootstrap+jQuery）提供了项目模板。<br>自动创建Javascript 的代理层来更方便使用Web API<br>封装一些Javascript 函数，更方便地使用ajax、消息框、通知组件、忙状态的遮罩层等等</p><h3 id="除ABP框架项目以外，还开发了名叫“Zero”的模块，实现了以下功能："><a href="#除ABP框架项目以外，还开发了名叫“Zero”的模块，实现了以下功能：" class="headerlink" title="除ABP框架项目以外，还开发了名叫“Zero”的模块，实现了以下功能："></a>除ABP框架项目以外，还开发了名叫“Zero”的模块，实现了以下功能：</h3><ul><li>用户，角色，权限和组织单位管理界面。</li><li>租户，版本和功能管理界面，租户订阅系统。</li><li>Xamarin移动应用程序。</li><li>设置管理界面。</li><li>动态语言管理用户界面，RTL支持。</li><li>实时聊天和通知系统。</li><li>审核日志报告用户界面。</li><li>用户个人资料，帐户链接，模拟，社交登录等…</li><li>基于Metronic的主题。</li></ul><h2 id="ABP不是什么？"><a href="#ABP不是什么？" class="headerlink" title="ABP不是什么？"></a>ABP不是什么？</h2><p>ABP 提供了一个应用程序开发模型用于最佳实践。它拥有基础类、接口和工具使我们容易建立起可维护的大规模的应用程序。</p><p>然而：</p><ul><li><p>它不是RAD工具之一，RAD工具的目的是无需编码创建应用程序。相反，ABP提供了一种编码的最佳实践。</p></li><li><p>它不是一个代码生成工具。在运行时虽然它有一些特性构建动态代码，但它不能生成代码。</p></li><li><p>它不是一个一体化的框架。相反，它使用流行的工具/库来完成特定的任务（例如用EF做ORM，用Log4Net做日志记录，使得Castle Windsor作为赖注入容器， Angular，Vue，React 用于SPA 框架）。</p></li></ul><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>ABP</tag>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(3):架构设计</title>
    <url>/posts/1868140162/</url>
    <content><![CDATA[<p>或许会有人觉得很奇怪，这么芝麻小点的项目，还需要进行架构设计吗？</p><a id="more"></a><p>其实所谓的架构设计，并不是什么高深莫测东西，无论你是否了解，它确实的存在于我们软件开发过程中的各个环节中。哪怕你没有专门去做过架构设计，但你在构想项目时，就已经悄无声息的把它包含了进去。</p><p>比如，你至少考虑过技术选型；稍微深入一点的话，或许你还考虑过是使用三层架构还是五层架构等等；如果更深入一些的话，或许还考虑过数据建模、DDD 之类的。</p><p>这些想法，无论是否落在纸面上，都是在进行架构设计，或者说是架构设计的一部分。每一个开发工程师，都是架构师的种子。这也是为什么大多数优秀的架构师，都是从经验丰富的开发工程师一路升级而来。</p><p>麻雀虽小五脏俱全，接下来，用几张简单易懂的 C4 模型图，简要阐明这个项目的架构设计。</p><blockquote><p>如果对“C4 模型”感兴趣的同学，可以看一下这篇文章：<a href="https://www.infoq.cn/article/C4-architecture-model" target="_blank" rel="noopener">用于软件架构的 C4 模型</a>。不想看长篇大论的话，那这里就用一句话概括：C4 模型是一种简单、直观、易于被各层次开发人员、业务人员所理解的架构设计图。</p></blockquote><h3 id="C4-语境图"><a href="#C4-语境图" class="headerlink" title="C4 语境图"></a>C4 语境图</h3><p>语境图是用来表明项目所处的场景，与哪些外部系统有关联。由于我们这个项目的场景非常简单，语境图的意义不大，就略过了，直接看容器图。</p><h3 id="C4-容器图"><a href="#C4-容器图" class="headerlink" title="C4 容器图"></a>C4 容器图</h3><p>容器图简单来说，是语境图的放大，它可以帮助了解组成项目各个部分的技术选型，以及它们的关系。</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BASP-NET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%A2%E5%8D%95%E9%87%87%E9%9B%86%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-23-16-28-29-%E8%AE%A2%E5%8D%95%E9%87%87%E9%9B%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E5%AE%B9%E5%99%A8%E5%9B%BE.jpg" alt="[ASP-NET-Core-3-0-项目实战之订单采集小程序-第三章-架构设计]-2019-10-23-16-28-29-订单采集小程序 容器图.jpg"><p>由此图可见，我们的用户主体是【业务员】；用户通过钉钉访问小程序【订单采集】，Web API 应用为其提供数据功能接口；由于使用的是钉钉内部登录，所以需要外部系统【钉钉开发平台】的支持。</p><p>需要说明的是，Redis 缓存用来存放用户的 Session 与 订单数据。订单数据为用户登录后默认加载的 TOP 20 历史订单。为什么是 TOP 20，不是 TOP 30，不是全部？</p><p>这一点等看完下张图，我们再解释。</p><h3 id="C4-组件图"><a href="#C4-组件图" class="headerlink" title="C4 组件图"></a>C4 组件图</h3><p>组件图是将容器图中的应用进一步放大，它可以帮助我们了解应用的组成部分（组件），以及各个组件之间的关系。我们的实际开发，也是以此图为引导进行。</p><p>注意：这并不是UML类图，它比类图要更加抽象一些，也更加容易理解。</p><h4 id="钉钉应用-组件图"><a href="#钉钉应用-组件图" class="headerlink" title="钉钉应用 组件图"></a>钉钉应用 组件图</h4><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BASP-NET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%A2%E5%8D%95%E9%87%87%E9%9B%86%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-23-16-29-39-%E8%AE%A2%E5%8D%95%E9%87%87%E9%9B%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E7%BB%84%E4%BB%B6%E5%9B%BE%20-%20%E9%92%89%E9%92%89%E5%BA%94%E7%94%A8.jpg" alt="[ASP-NET-Core-3-0-项目实战之订单采集小程序-第三章-架构设计]-2019-10-23-16-29-39-订单采集小程序 组件图 - 钉钉应用.jpg"><p>现在我可以回答上面的问题了。</p><p>从这张图中，我们很容易的就可以知道，用户登录后的实际页面就是【订单列表】，而【首页】只是起了一个登录跳转的作用。那么回顾一下我们的需求分析里【查询历史订单】的业务描述：</p><blockquote><p>默认查询用户的最近 20 条历史订单记录</p></blockquote><p>这说明，用户最近 20 条历史订单，相对来说访问频率较高。况且它还是实际的首屏页面，也需要更快的加载速度。</p><h4 id="Web-API-应用-组件图"><a href="#Web-API-应用-组件图" class="headerlink" title="Web API 应用 组件图"></a>Web API 应用 组件图</h4><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BASP-NET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%A2%E5%8D%95%E9%87%87%E9%9B%86%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-23-16-30-10-%E8%AE%A2%E5%8D%95%E9%87%87%E9%9B%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E7%BB%84%E4%BB%B6%E5%9B%BE%20-%20Web%20API%20%E5%BA%94%E7%94%A8.jpg" alt="[ASP-NET-Core-3-0-项目实战之订单采集小程序-第三章-架构设计]-2019-10-23-16-30-10-订单采集小程序 组件图 - Web API 应用.jpg"><p>这么个简单的小项目用不到复杂的架构，所以这里采用了 FreeSQL 作为 ORM 框架，其中 FreeSQL.Repository 可以直接作为我们的仓储层；然后只需要封装下缓存管理器和钉钉开放平台客户端，就可以直接在控制器里写业务了</p><h3 id="数据库模型"><a href="#数据库模型" class="headerlink" title="数据库模型"></a>数据库模型</h3><p>极简设计，三张表足矣。</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BASP-NET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%A2%E5%8D%95%E9%87%87%E9%9B%86%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-23-16-30-27-image-20191020192225449.png" alt="[ASP-NET-Core-3-0-项目实战之订单采集小程序-第三章-架构设计]-2019-10-23-16-30-27-image-20191020192225449.png"><h4 id="商品资料表"><a href="#商品资料表" class="headerlink" title="商品资料表"></a>商品资料表</h4><p>简易版的商品资料，原系统的商品资料表有二十多个字段，我进行了简化，这里并不是重点。</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BASP-NET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%A2%E5%8D%95%E9%87%87%E9%9B%86%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-23-16-30-44-image-20191020191338848.png" alt="[ASP-NET-Core-3-0-项目实战之订单采集小程序-第三章-架构设计]-2019-10-23-16-30-44-image-20191020191338848.png"><h4 id="订单表"><a href="#订单表" class="headerlink" title="订单表"></a>订单表</h4><p>订单其实是两个表：</p><ol><li>「订单主表」记录订单的主要数据，比如订单编号、订单状态、创建时间、创建人等；</li><li>「订单明细表」记录订单中的商品明细，字段「oid」是订单编号，可以设置为「索引」。</li></ol><p>需要注意：用户创建订单后，订单状态「state」默认为「0」，即「未确认」。后台审核后，「state」更新为「1」，即「已确认」。我们这个案例，并不牵扯后台的业务，只需要查出其值即可。</p><center>订单主表</center><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BASP-NET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%A2%E5%8D%95%E9%87%87%E9%9B%86%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-23-16-31-5-image-20191020192454093.png" alt="[ASP-NET-Core-3-0-项目实战之订单采集小程序-第三章-架构设计]-2019-10-23-16-31-5-image-20191020192454093.png"><center>订单明细表</center><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5BASP-NET-Core-3-0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%A2%E5%8D%95%E9%87%87%E9%9B%86%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%5D-2019-10-23-16-31-18-image-20191020193146334.png" alt="[ASP-NET-Core-3-0-项目实战之订单采集小程序-第三章-架构设计]-2019-10-23-16-31-18-image-20191020193146334.png"><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(2):需求分析</title>
    <url>/posts/3510016629/</url>
    <content><![CDATA[<p>做任何项目前，无论大小，都应该养成需求分析的习惯。这个分析不一定要非常细致，但要尽量全面。</p><p>为什么说不要求非常细致？</p><a id="more"></a><p>因为在实际的开发中，需求总是会变化。细致的需求分析不仅耽误时间，也会陷入钻牛角的情况，若以后需求有了变化，那样不仅白白做了工，很多东西或许还要推倒重来。但也不能因此什么都不做，我见过许多初中级开发人员，拿到一纸需求后，追求效率，略微在大脑里构想一遍，就开始动手 coding 了。</p><p>虽然这样有时候很快，但也有不少时候由于分析的不到位，或者说，由于没有落到文档上形成参考标准，导致在开发时，自己的构想不断变化，反复推倒自己的代码，进而造成效率低下。</p><p>记住，慢就是快。在进行需求分析时，我倾向于从用户角度出发，这样不仅理清了需求，甚至连业务流程也能包含进来。虽然不够详细，但作为指导方向是很不错的，同时也可以帮助我们对业务更加熟悉。</p><p>再说一遍，不一定要非常细致，但要尽量全面。</p><h3 id="需求概述"><a href="#需求概述" class="headerlink" title="需求概述"></a>需求概述</h3><ul><li>业务场景：业务员外出采购时，通过钉钉来提交、管理采购订单。订单内容包括商品资料、采购数量、采购日期、审核日期、状态、采购人（业务员）。</li><li>功能需求：历史订单查询、订单明细查询、订单录入、订单修改、订单删除</li></ul><h4 id="历史订单查询"><a href="#历史订单查询" class="headerlink" title="历史订单查询"></a>历史订单查询</h4><ul><li>业务描述：默认查询用户的最近 20 条历史订单记录，可以查看更多历史订单，筛选订单状态（已确认、未确认）。</li><li>功能描述：<ol><li>用户登录后跳转到【我的订单】页面，查询用户订单；</li><li>该页面为订单列表，显示日期、数量、订单号、状态四列内容；</li><li>点击【状态】列头，可以选择订单状态。</li></ol></li></ul><h4 id="订单明细查询"><a href="#订单明细查询" class="headerlink" title="订单明细查询"></a>订单明细查询</h4><ul><li>业务描述：查询订单中的包含的所有商品资料（条码、名称、类别、数量），订单的基本资料（日期、数量、订单号、状态）。</li><li>功能描述：<ol><li>用户点击【我的订单】列表中的订单号，跳转到【订单明细】页面；</li><li>该页面显示订单的基本资料与商品列表。</li></ol></li></ul><h4 id="订单录入"><a href="#订单录入" class="headerlink" title="订单录入"></a>订单录入</h4><ul><li>业务描述：录入的新增订单默认日期为当日，订单中可以添加商品；商品添加只需要输入商品条码，自动读取商品资料；新订单的状态为未确认。</li><li>功能描述：<ol><li>用户点击【我的订单】列表中的【创建新订单】按钮，跳转到【新增订单】页面；</li><li>订单默认日期为当日，默认状态为【未确认】；</li><li>点击【添加商品】按钮，弹出商品录入表单，用户输入条码后，查询该条码的商品资料，并回填到表单中，供用户确认；</li><li>确认商品资料，填入数量；</li><li>单击商品记录弹出商品资料表单，可以修改数量、删除商品；</li></ol></li></ul><h4 id="订单修改"><a href="#订单修改" class="headerlink" title="订单修改"></a>订单修改</h4><ul><li>业务描述：用户只能修改状态为“未确认”的订单，已确认订单不可修改；只能修改订单的“日期”与商品明细。</li><li>功能描述：<ol><li>用户点击【我的订单】列表中【未确认】状态列，跳转到【订单修改】页面；</li><li>载入【订单修改】页面，查询目标订单的所有数据；</li><li>订单商品明细的添加、删除、修改与【订单录入】模块的逻辑相同；</li></ol></li></ul><h4 id="订单删除"><a href="#订单删除" class="headerlink" title="订单删除"></a>订单删除</h4><ul><li>业务描述：用户只能删除状态为“未确认”的订单，已确认订单不可删除。</li><li>功能描述：<ol><li>用户点击【我的订单】列表中【未确认】状态列，跳转到【订单修改】页面；</li><li>查询目标订单的所有数据，并载入【订单修改】页面；</li><li>点击【删除订单】按钮，弹出确认删除提示框，再次点击“删除”按钮，将该订单永久删除。</li></ol></li></ul><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 3.0 项目实战之订单采集小程序(1):项目概述</title>
    <url>/posts/2337956806/</url>
    <content><![CDATA[<p>此案例是某 ERP 系统中的一个相对独立的SOA模块，因为这个 ERP 系统使用的技术相对来说比较老了，故而将其抽离出来，使用 ASP.NET Core 3.0 进行重构。</p><a id="more"></a><p>由于把这个模块从原系统中抽离了出来，自然也剥离了一些业务，所以简化了不少，功能也就简单多了。依然是以增删改查为核心，并没有什么难度，也没有什么高并发的需求，所以这篇教程比较适合接触过 .NET Core 的朋友。</p><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>『订单采集』一个是作为『企业内部应用』运行在钉钉中的小程序，用户对象是企业内部员工（业务员）。</p><p>业务员外出采购时，在钉钉里使用『订单采集』提交、管理自己的采购订单，订单的数据存放在 ERP 业务数据库里，由上级进行审批。不过，这个项目只有『订单采集』小程序的部分，审批流程在 ERP 系统中。</p><p>使用钉钉的好处是可以利用钉钉开放平台，由小程序拉取钉钉通讯录，读取用户工号等基本用户信息，实现无感登录。这对于中小型公司来说，免去了 CRM 系统的建设。</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>.NET Core 最大的特性就是跨平台，所以为了体验它的跨平台特性，索性就从跨平台开发开始。</p><p>本案例的系统环境为 Mac OS Catalina(10.15)，所用到的开发工具也全部采用支持跨平台的，以保证在 Windows 系统下具有一致性操作。</p><h3 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h3><p>虽然宇宙第一 IDE（Visual Studio）也有 Mac 版本，但是用起来还是与 Windows 版本有很大差距，真的很不好用。所以，我选择了 Visual Studio Code。</p><p>钉钉开放平台提供的 『小程序开发者工具』，也同样支持跨平台，Mac 版本和 Win 版本完全一样。</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>本案例采用 MySql 作为数据库，版本 5.7 及以上即可。当然，大家也可以使用其它的主流关系型数据库，基本上不需要什么改动。</p><p>数据库管理工具则使用 Navicat，还有什么比它更简单好用的可视化跨平台数据库管理工具呢？反正我不知道，如果你知道，请告诉我！</p><h4 id="源代码管理"><a href="#源代码管理" class="headerlink" title="源代码管理"></a>源代码管理</h4><p>本案例的代码与数据库，我会全部上传GitHub，所以也自然而然的使用 Git 作为源代码管理工具了。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>接口自动化测试工具 Postman，API 文档工具 swagger 也可以进行简单的接口测试。</p><h4 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h4><p>简单来说，API 应用、数据库、缓存、Web 服务器均采用 Linux 环境下的 Docker 化部署。</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul><li>ASP.NET Core 3.0 Web API</li><li>FreeSql</li><li>Redis</li><li>MySql</li><li>钉钉小程序</li><li>swagger</li><li>Docker</li><li>Git</li></ul><blockquote><p>该篇文章会随着教程进度更新</p></blockquote><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li></li><li></li><li></li><li></li></ul><p>未完待续</p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>订单采集小程序</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>创建nuget包极简教程</title>
    <url>/posts/542292805/</url>
    <content><![CDATA[<p>发布一个 nuget 包非常容易，简单来说只需要三步：设置属性、创建包、发布包。这一篇极简教程，省去了很多细节，但绝对简单。下面我们看看具体如何做。</p><p>如果没有 nuget 账号，去<a href="https://www.nuget.org/" target="_blank" rel="noopener">官网</a>注册先。</p><a id="more"></a><h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><p>假设你有一个名为 MyPackage 的类库。</p><p>创建包需要以下属性。</p><ul><li>PackageId，包标识符，在托管包的库中必须是唯一的。如果未指定，默认值为 AssemblyName。</li><li>Version，窗体 Major.Minor.Patch[-Suffix] 中特定的版本号，其中 -Suffix 标识预发布版本 。如果未指定，默认值为 1.0.0。</li><li>Authors，作者和所有者信息。如果未指定，默认值为 AssemblyName。</li><li>Company，公司名称。如果未指定，默认值为 AssemblyName。</li></ul><p>首先，在项目文件 (MyPackage.csproj) 的<code>PropertyGroup</code>节点中添加以下属性：</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%9B%E5%BB%BAnuget%E5%8C%85%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B%5D-2019-10-26-14-5-7.png" alt></p><h3 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h3><ol><li><p>在命令行工具中运行以下命令，先生成二进制文件：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">dotnet build -c Release</span><br></pre></td></tr></tbody></table></figure></li><li><p>然后打包:</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">dotnet pack -o nupkgs -c Release</span><br></pre></td></tr></tbody></table></figure><p>看看项目的 nupkgs 目录下，是不是多了一个 MyPackage.nupkg 文件</p></li></ol><h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><ol><li><p><a href="https://docs.microsoft.com/zh-cn/nuget/nuget-org/scoped-api-keys#acquire-an-api-key" target="_blank" rel="noopener">获取 Nuget API 密钥</a></p></li><li><p>在命令行工具中处运行以下命令，将 <code><你的密钥></code> 替换为从 nuget.org 获取的密钥：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">nuget setApiKey <你的密钥></span><br><span class="line"><span class="comment"># 此命令将 API 密钥存储在本台计算机的 NuGet 配置中，以后就不用再配置了。</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>使用以下命令将包推送到 NuGet 库：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">nuget push nupkgs/MyPackage.nupkg -Source https://api.nuget.org/v3/index.json</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>登录 nuget 账号，通过菜单进入 Manage Packages 页面，就可以看到你刚刚推送的包了。</p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>Nuget</tag>
      </tags>
  </entry>
  <entry>
    <title>一个故事告诉你什么是消息队列</title>
    <url>/posts/1805459380/</url>
    <content><![CDATA[<p>挺有意思的，有兴趣可以看看。</p><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>有一天，产品跑来说：“我们要做一个用户注册功能，需要在用户注册成功后给用户发一封成功邮件。”</p><p>小明（攻城狮）：“好，需求很明确了。” 不就提供一个注册接口，保存用户信息，同时发起邮件调用，待邮件发送成功后，返回用户操作成功。没一会功夫，代码就写完了。验证功能没问题后，就发布上线了。</p><p>线上正常运行了一段时间，产品匆匆地跑来说：“你做的功能不行啊，运营反馈注册操作响应太慢，已经有好多用户流失了。”</p><p>小明听得一身冷汗，赶紧回去改。他发现，原先的以单线程同步阻塞的方式进行邮件发送，确实存在问题。这次，他利用了 JAVA 多线程的特性，另起线程进行邮件发送，主线程直接返回保存结果。测试通过后，赶紧发布上线。小明心想，这下总没问题了吧。</p><p>没过多久，产品又跑来了，他说：“现在，注册操作响应是快多了。但是又有新的问题了，有用户反应，邮件收不到。能否在发送邮件时，保存一下发送的结果，对于发送失败的，进行补发。”</p><p>小明一听，哎，又得熬夜加班了。产品看他一脸苦逼的样子，忙说：“邮件服务这块，别的团队都已经做好了，你不用再自己搞了，直接用他们的服务。”</p><p>小明赶紧去和邮件团队沟通，谁知他们的服务根本就不对外开放。这下小明可开始犯愁了，明知道有这么一个服务，可是偏偏又调用不了。</p><p>邮件团队的人说，“看你愁的，我给你提供了一个类似邮局信箱的东西，你往这信箱里写上你要发送的消息，以及我们约定的地址。之后你就不用再操心了，我们自然能从约定的地址中取得消息，进行邮件的相应操作。”</p><p>后来，小明才知道，这就是外界广为流传的消息队列。你不用知道具体的服务在哪，如何调用。你要做的只是将该发送的消息，向你们约定好的地址进行发送，你的任务就完成了。对应的服务自然能监听到你发送的消息，进行后续的操作。这就是消息队列最大的特点，将同步操作转为异步处理，将多服务共同操作转为职责单一的单服务操作，做到了服务间的解耦。</p><p>哈哈，这下能高枕无忧了。太年轻，哪有万无一失的技术啊~</p><p>不久的一天，你会发现所有业务都替换了邮件发送的方式，统一使用了消息队列来进行发送。这下仅仅一个邮件服务模块，难以承受业务方源源不断的消息，大量的消息堆积在了队列中。这就需要更多的消费者（邮件服务）来共同处理队列中的消息，即所谓的分布式消息处理。</p><p>未完待续。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>有了上面的基础，再看非常官方的解释应该也能理解了。</p><p>消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。 ——维基百科</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>解释还是太官方了，我们来看一个最简单的架构模型：</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E5%91%8A%E8%AF%89%E4%BD%A0%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5D-2019-10-12-23-40-18-mq_01.png" alt="[一个故事告诉你什么是消息队列]-2019-10-12-23-40-18-mq_01.png"><ul><li>Producer：消息生产者，负责产生和发送消息到 Broker；</li><li>Broker：消息处理中心。负责消息存储、确认、重试等，一般其中会包含多个 queue；</li><li>Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理；</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h4><p>将耗时的同步操作，通过以发送消息的方式，进行了异步化处理。减少了同步等待的时间。</p><h4 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h4><p>消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节，只要定义好消息的格式就行。</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>通过对消费者的横向扩展，降低了消息队列阻塞的风险，以及单个消费者产生单点故障的可能性（当然消息队列本身也可以做成分布式集群）。</p><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>消息队列一般会把接收到的消息存储到本地硬盘上（当消息被处理完之后，存储信息根据不同的消息队列实现，有可能将其删除），这样即使应用挂掉或者消息队列本身挂掉，消息也能够重新加载。</p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 GitHub Pages 和 Hugo 搭建博客</title>
    <url>/posts/3355505068/</url>
    <content><![CDATA[<p>之前一直在用 wordpress 写博客，服务器放在国外。但是，最近服务器到期，一来是不想再用 wp 了（审美疲劳），二来就是不想再续费了，思来想去，最终决定换个地方写博客。</p><p>感谢 GitHub 给了我们免费的主页空间（GitHub Pages），还有 Hugo 这种好用、好看又强大的静态站点生成框架，最后再结合 Markdown 写文章，真香 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61a.png?v8">😚</span>。</p><a id="more"></a><p>本文主要是记录了搭建过程，和一些使用心得，步骤尽量简短明了。不过，为了确保萌新也可以学会，有些非本文关注的地方，链接到了其他教程（偷懒 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>）。</p><p>话不多说，进入正题。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>如果你没有 GitHub 账号，那么需要先注册一个。<a href="https://www.dogedoge.com/results?q=github+注册" target="_blank" rel="noopener">注册教程戳这里</a>，选一篇适合你的，去注册吧。</p></li><li><p><a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="noopener">Git</a> 是必须的。</p></li><li><p>再有个 <a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">Visaul Studio Code</a> 那就更好了。</p></li></ol><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>我们需要在 GitHub 上创建三个仓库，分别是：</p><ol><li><p>hugo-blog 仓库，这个是用来存放 hugo 框架与主题，最重要的是，我们写的博客文章的md文件一般是放在这里的。</p></li><li><p>GitHub Pages 仓库，用来存放生成好的静态博客站点，按照<a href="https://pages.github.com/" target="_blank" rel="noopener">官网教程</a>来就好。这里需要注意的是，仓库名字的前缀必须要和你的账号相同，这样才会生成 <code>xxxx.github.io</code> 的域名。</p></li><li><p>figurebed 仓库，就是图床啦，用来存放文章图片的，专门用个仓库比较好管理。</p></li></ol><p>假设以下就是上述的三个仓库：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">UserName/hugo-blog.git</span><br><span class="line">UserName/UserName.github.io.git</span><br><span class="line">UserName/figurebed.git</span><br></pre></td></tr></tbody></table></figure><h2 id="安装-Hugo"><a href="#安装-Hugo" class="headerlink" title="安装 Hugo"></a>安装 Hugo</h2><p>Mac 直接使用 Homebrew 安装：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">brew install hugo</span><br></pre></td></tr></tbody></table></figure><p>Windows 需要<a href="https://github.com/gohugoio/hugo/releases" target="_blank" rel="noopener">下载安装包</a>。</p><p>安装完成后，在终端输入以下命令，验证一下：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hugo version</span><br></pre></td></tr></tbody></table></figure><p>如下图所示，说明安装成功</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-13-25-41-BC90513A-87BF-4F0D-AFBD-45F7CB697E20.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-13-25-41-BC90513A-87BF-4F0D-AFBD-45F7CB697E20.png"><h2 id="创建-Hugo-项目"><a href="#创建-Hugo-项目" class="headerlink" title="创建 Hugo 项目"></a>创建 Hugo 项目</h2><p>命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hugo new site my-blog</span><br></pre></td></tr></tbody></table></figure><p><code>my-blog</code> 是 Hugo 项目的目录名称，可以替换为你喜欢的名称。</p><p>创建完成后，在 <code>my-blog</code> 目录下会生成以下文件结构（只列出我们关心的）：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">├── archetypes <span class="comment"># 用户自定义的文章模板</span></span><br><span class="line">├── content <span class="comment"># markdown 文件</span></span><br><span class="line">├── static <span class="comment"># 存放静态文件，比如图片</span></span><br><span class="line">└── themes <span class="comment"># 主题</span></span><br></pre></td></tr></tbody></table></figure><p>用 vs code 打开 <code>my-blog</code> 目录，然后就可以在 vs code 的终端中执行命令了。</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>Hugo 的主题还是比较多的，它们不仅风格迥异，功能也有所不同。但是，很多主题功能都比较简单了，这显然不在我考虑的范围内，所以我选择了 <a href="https://github.com/olOwOlo/hugo-theme-even" target="_blank" rel="noopener">even</a> 这个功能强大、干净又好看的主题。</p><p>当然，你也可以在 <a href="https://themes.gohugo.io/" target="_blank" rel="noopener">Hugo 主题市场</a> 里自己挑选。</p><p>把主题克隆到 <code>themes</code> 目录里就算是安装了：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/olOwOlo/hugo-theme-even themes/even</span><br></pre></td></tr></tbody></table></figure><p>然后把 <code>themes/even/exampleSite</code> 目录下的所有文件（配置文件与示例文档）全都复制到 <code>my-blog</code> 目录下。</p><p>这样就算安装完成了。</p><h2 id="生成与运行"><a href="#生成与运行" class="headerlink" title="生成与运行"></a>生成与运行</h2><p>如前文所说，Hugo 本身并不是一个博客系统，而是一个静态站点的生成框架，配合不同的主题，可以生成出不同的静态站点。</p><p>命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hugo -t even <span class="comment"># 生成站点()，even 是主题名字</span></span><br><span class="line">hugo server <span class="comment"># 生成好了以后，就可以运行了</span></span><br></pre></td></tr></tbody></table></figure><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-14-16-28-WX20191013-141617.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-14-16-28-WX20191013-141617.png"><p>图中红框中就是本地访问地址，可以打开先看看效果。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p><code>my-blog/config.toml</code> 文件就是主题的配置文件，配置项比较丰富，不过好在基本都有中文注释，根据需要自行修改就行了。</p><p>另外，<code>my-blog/static</code> 目录下，可以放一些静态文件，每次 hugo 生成站点时，都会把这个目录里的文件复制到生成的站点中。</p><p>比如，你可以把打赏二维码的图片丢进去</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-14-54-31-20191013145431.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-14-54-31-20191013145431.png"><p>然后修改一下配置里的路径</p><p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-14-43-9-20191013144309.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-14-43-9-20191013144309.png"></p><h2 id="写新文章"><a href="#写新文章" class="headerlink" title="写新文章"></a>写新文章</h2><p>使用命令：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hugo new post/文章名称.md</span><br></pre></td></tr></tbody></table></figure><p>hugo 会使用位于 <code>my-blog/archetypes/default.md</code> 的用户模板文件，在 <code>my-blog/content/post</code>中创建新的文章。</p><p>主题中自带的模板配置项会比较多，可以参考<code>themes/even/archetypes/default.md</code>，自行在文章中或者和用户模板中添加需要的配置项。</p><p>不管是写了新文章，还是修改、删除了原来的文章，都要删除掉以前的 public 目录，然后重新生成站点。</p><blockquote><p>不要忘记把之前的示例文章删掉</p></blockquote><h2 id="部署上线"><a href="#部署上线" class="headerlink" title="部署上线"></a>部署上线</h2><p>还记得之前我们创建的三个 github 仓库吗？</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">UserName/hugo-blog.git <span class="comment"># my-blog 在这里</span></span><br><span class="line">UserName/UserName.github.io.git <span class="comment"># public 放这里</span></span><br><span class="line">UserName/figurebed.git <span class="comment"># 后面再说这个图床怎么用</span></span><br></pre></td></tr></tbody></table></figure><p>接下来，我们就要把博客上传到仓库中，<code>my-blog</code> 目录下执行以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 删掉 public 文件夹，因为每次发布前，都要重新生成它。</span></span><br><span class="line">rm -rf public</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 git</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关联 github 仓库 UserName/hugo-blog.git</span></span><br><span class="line">git remote add origin https://github.com/UserName/hugo-blog.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 public 子模块，生成的站点需要放在 UserName/UserName.github.io.git 仓库里</span></span><br><span class="line">git submodule add https://github.com/UserName/UserName.github.io.git public</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送过去，如果是第一次用 git，这里会让你输入账号和密码</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 public 站点</span></span><br><span class="line">hugo -t even</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 public 目录</span></span><br><span class="line"><span class="built_in">cd</span> public</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交，刚才提交的是 my-blog 库，现在提交的是 public</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个也推送过去</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></tbody></table></figure><p>打完收工 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8">😃</span></p><p>现在可以打开 <code>UserName.github.io</code> 去看看你的博客了。</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>如果每一次写文章都要这么发布一次，确实也挺累了，所以我们写个 shell。</p><p>创建一个 <code>deploy.sh</code> 文件，把以下命令复制进去。这样以后编辑文章，在终端中执行一下就行了。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"\033[0;32mDeploying blog updates to GitHub...\033[0m\n"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除旧发布目录</span></span><br><span class="line">rm -rf ./public</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 public.</span></span><br><span class="line">hugo -t even</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成提交信息.</span></span><br><span class="line">msg=<span class="string">"rebuilding site <span class="variable">$(date)</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"$*"</span> ]; <span class="keyword">then</span></span><br><span class="line">    msg=<span class="string">"$*"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交&推送 hugo-blog</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"<span class="variable">$msg</span>"</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"\n\033[0;32mDeploying public updates to GitHub...\033[0m\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> public</span><br><span class="line"><span class="comment"># 还原 public git 子模块</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"gitdir: ../.git/modules/public"</span> > <span class="string">".git"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交&推送 public</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"<span class="variable">$msg</span>"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></tbody></table></figure><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>因为我们使用 markdown 写博客，所以文章配图需要先上传某个服务器，然后再把地址贴上来，这样显然会比较麻烦。</p><p>当然，在 <code>vs code</code> 里没有什么麻烦是插件解决不了的。</p><p>在 <code>vs code</code> 中安装 <a href="https://marketplace.visualstudio.com/items?itemName=Spades.vs-picgo" target="_blank" rel="noopener">picgo</a> 这个插件。</p><p>然后进入该插件配置项</p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-15-39-9-20191013153909.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-15-39-9-20191013153909.png" width="300"><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A" target="_blank" rel="noopener">GitHub Token 获取方式</a></p><img src="https://raw.githubusercontent.com/buker2012/figurebed/master/%5B%E5%88%A9%E7%94%A8%20GitHub%20Pages%20%E5%92%8C%20Hugo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D-2019-10-13-15-41-20-20191013154119.png" alt="[利用 GitHub Pages 和 Hugo 搭建博客]-2019-10-13-15-41-20-20191013154119.png" width="400"><p>配置完以后，就可以使用它来帮我们上传图片（文件、截图等）了，它会帮我们把图片地址自动回填到编辑器的光标处。</p><h3 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h3><table><thead><tr><th>系统</th><th>剪切板(截图)</th><th>资源管理器(文件)</th></tr></thead><tbody><tr><td>Win</td><td>Ctrl + Alt + U</td><td>Ctrl + Alt + E</td></tr><tr><td>Mac</td><td>Cmd + Opt + U</td><td>Cmd + Opt + E</td></tr></tbody></table><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
